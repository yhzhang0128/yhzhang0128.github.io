import{_ as s}from"./chunks/mstatus.AnuZ0eMl.js";import{_ as e,c as i,o as a,a2 as n}from"./chunks/framework.CeQAp18V.js";const t="/assets/mcause.Csy74TI4.png",E=JSON.parse('{"title":"System Call & Protection","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"book/p3_syscall.md","filePath":"book/p3_syscall.md"}'),l={name:"book/p3_syscall.md"},p=n('<h1 id="system-call-protection" tabindex="-1">System Call &amp; Protection <a class="header-anchor" href="#system-call-protection" aria-label="Permalink to &quot;System Call &amp; Protection&quot;">​</a></h1><p>You have seen how an operating system manages the life cycles of threads (or processes, as we don&#39;t distinguish the two now), and preemptively schedules multiple threads with the help of timer interrupts. This project helps you understand two more things.</p><ul><li>How do threads invoke <strong>system calls</strong> to communicate with each other?</li><li>How does an operating system <strong>protect its memory</strong>, so malicious threads cannot corrupt the system calls by modifying the code or data of the operating system?</li></ul><p>System calls and memory protection rely on <strong>exception handling</strong> which is similar to interrupt handling. We thus start by introducing exception handling.</p><h2 id="exception-handling" tabindex="-1">Exception handling <a class="header-anchor" href="#exception-handling" aria-label="Permalink to &quot;Exception handling&quot;">​</a></h2><p>An <strong>exception</strong> happens if something goes wrong when the CPU executes an instruction. For example, an exception would happen when an instruction tries to access the memory at an invalid address. Instead of ignoring the problem and proceeding to the next instruction, the CPU automatically jumps to a special function called an <strong>exception handler</strong>, just like how the CPU jumps to the interrupt handler when receiving a timer interrupt. Indeed, we will use the same function to handle both interrupts and exceptions, and use the <code>mcause</code> CSR to reveal what has caused the CPU to jump to the handler function.</p><h3 id="the-mcause-csr" tabindex="-1">The <code>mcause</code> CSR <a class="header-anchor" href="#the-mcause-csr" aria-label="Permalink to &quot;The `mcause` CSR&quot;">​</a></h3><p>Below are the screenshots of Table 22 and Table 23 from <a href="assets/sifive-fe310-v19p04-1.pdf">this document</a> which describe the <code>mcause</code> CSR. You can further read chapter 3.1.15 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>. When an exception or interrupt happens, the CPU will set the value of <code>mcause</code> before jumping to the handler function.</p><p><img src="'+t+`" alt="Failed to load picture"></p><p>For example, <code>mcause</code> is set to <code>0x80000007</code> when the CPU receives a timer interrupt. Bit#31 of <code>mcause</code> is set to 1 because the timer interrupt is an interrupt. The exception code is set to <code>0b0000000111</code> because 7 is the code for machine timer interrupt. When the CPU meets an illegal instruction (i.e., the 4 bytes pointed by the program counter cannot decode into a CPU instruction), <code>mcause</code> will be set to <code>0x2</code> before the CPU jumps to the handler.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Exceptions are different from interrupts. Exceptions are triggered by CPU instructions that cause something wrong. Interrupts are triggered by devices outside of the CPU, such as a timer, a disk, or a network interface controller. The <code>mcause</code> CSR helps the operating system understand which particular interrupt or exception needs to be handled.</p></div><h3 id="the-ecall-exception" tabindex="-1">The <code>ecall</code> exception <a class="header-anchor" href="#the-ecall-exception" aria-label="Permalink to &quot;The \`ecall\` exception&quot;">​</a></h3><p>Most exceptions happen due to something wrong such as invalid memory access. However, RISC-V provides a special instruction, <code>ecall</code>, which triggers the so-called environment call exception intentionally (see exception #8 and #11 in Table 23). This instruction is for <strong>system calls</strong>: if a thread invokes <code>ecall</code>, the control flow will transfer to the operating system which will serve a system call for this thread.</p><p>In egos-2000, <code>ecall</code> is used in <code>library/syscall/syscall.c</code>. Specifically, <code>asm(&quot;ecall&quot;)</code> will raise an environment call exception and then the CPU will jump to <code>trap_entry</code> as you have seen in P2. <code>trap_entry</code> calls <code>kernel_entry</code> which further calls <code>excp_entry</code>, and <code>excp_entry</code> handles system calls within the if statement using this condition: <code>(id &gt;= EXCP_ID_ECALL_U &amp;&amp; id &lt;= EXCP_ID_ECALL_M)</code>. <code>EXCP_ID_ECALL_U</code> and <code>EXCP_ID_ECALL_M</code> are defined as 8 and 11 respectively according to Table 23. Take a look at how <code>mcause</code> has been read and used in <code>trap_entry</code> and <code>kernel_entry</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>The U-Mode and M-mode in Table 23 stand for user mode and machine mode. We will touch these privilege modes very soon when we start to explain memory protection.</p></div><h3 id="a-sketch-of-the-kernel" tabindex="-1">A sketch of the &quot;kernel&quot; <a class="header-anchor" href="#a-sketch-of-the-kernel" aria-label="Permalink to &quot;A sketch of the &quot;kernel&quot;&quot;">​</a></h3><p>We have been using the word &quot;kernel&quot; since P2, but we never explained what is a kernel. With the knowledge of <code>mcause</code>, we can show you a sketch of the <em>kernel</em>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kernel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mcause_val, id;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrr %0, mcause</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mcause_val));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mcause_val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mcause_val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">proc_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle_system_call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle_memory_access_fault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>The code above sketches the core of an operating system kernel:</p><ul><li>handle thread scheduling upon a timer interrupt</li><li>handle system calls when a thread invokes <code>ecall</code></li><li>handle other exceptions such as memory access faults</li></ul><p>We call it a sketch because a complete operating system needs to handle all the interrupts and exceptions, while the 3 bullets above are probably the most important ones. You have seen thread scheduling in P2, and P3 will give you hands-on experience with the last two bullets in this kernel sketch.</p><h2 id="inter-process-communication" tabindex="-1">Inter-process communication <a class="header-anchor" href="#inter-process-communication" aria-label="Permalink to &quot;Inter-process communication&quot;">​</a></h2><p>There are only 2 types of system calls in egos-2000. They are designed for inter-process communication (i.e., sending and receiving messages). We now introduce the system call interface for applications, and explain what happens within the OS kernel.</p><h3 id="application-side-interface" tabindex="-1">Application-side interface <a class="header-anchor" href="#application-side-interface" aria-label="Permalink to &quot;Application-side interface&quot;">​</a></h3><p>The code below is from <code>library/syscall/syscall.h</code>, and it defines the data structures for system calls in egos-2000.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall_type {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SYS_RECV </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SYS_SEND </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall_type type;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* SYS_SEND or SYS_RECV */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sender;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             /* sender process ID    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receiver;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           /* receiver process ID  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { PENDING, DONE } status;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>The <code>content</code> field holds the message being sent or received. Say process A wants to send a message to process B through <code>SYS_SEND</code>, this system call may not succeed immediately. It will only succeed after process B invokes the <code>SYS_RECV</code> system call with process A as the <code>sender</code> (i.e., process B is ready to receive a message from process A). For this reason, before process B invokes the <code>SYS_RECV</code> system call, the <code>SYS_SEND</code> system call by process A would have its <code>status</code> being <code>PENDING</code> instead of <code>DONE</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>In other words, egos-2000 implements a <em>blocking</em> version of inter-process communication such that a system call would only return after a message has been successfully sent or received. It is certainly possible to implement a <em>non-blocking</em> version such that system calls return immediately. egos-2000 implements the blocking version for simplicity of the code.</p></div><p>With <code>struct syscall</code> in mind, the system call interface <code>sys_send</code> and <code>sys_recv</code> defined in <code>library/syscall/syscall.c</code> should be easy to understand.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)SYSCALL_ARG;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sys_send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sc-&gt;type     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SYS_SEND;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sc-&gt;receiver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> receiver;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sc-&gt;content, msg, size);</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ecall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sys_recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sc-&gt;type   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SYS_RECV;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sc-&gt;sender </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from;</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ecall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf, sc-&gt;content, size);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sender) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sender </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sc-&gt;sender;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>Again, the <code>ecall</code> highlighted above will trigger an environment call exception, and then the CPU will jump to the exception handler (i.e., <code>trap_entry</code>) right after <code>ecall</code>.</p><h3 id="kernel-side-handling" tabindex="-1">Kernel-side handling <a class="header-anchor" href="#kernel-side-handling" aria-label="Permalink to &quot;Kernel-side handling&quot;">​</a></h3><p>The exception handler function in egos-2000 (i.e., <code>trap_entry</code> in <code>grass/kernel.s</code>) calls <code>kernel_entry()</code> which further calls <code>excp_entry()</code> after an environment call exception is raised by <code>ecall</code>. We now explain the following if-statement for system calls.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXCP_ID_ECALL_U </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EXCP_ID_ECALL_M) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Copy the system call arguments from user space to the kernel. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall_paddr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> earth-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mmu_translate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curr_pid, SYSCALL_ARG);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">proc_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[curr_proc_idx].syscall, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)syscall_paddr,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall));</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    proc_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[curr_proc_idx].syscall.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PENDING;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    proc_set_pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curr_pid);</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    proc_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[curr_proc_idx].mepc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    proc_try_syscall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">proc_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[curr_proc_idx]);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    proc_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>First of all, <code>proc_set[curr_proc_idx]</code> is the <code>struct process</code> of the current process which has just invoked the system call.</p><ul><li><p>Note that this process initialized the <code>struct syscall</code> data structure at memory address <code>SYSCALL_ARG</code>. Line#3 and #4 copy this data structure into the kernel. You can ignore the <code>earth-&gt;mmu_translate</code> for now, and we will explain it in P4. Line#6 sets the system call status to <code>PENDING</code> and line#8 sets the process status to <code>PROC_PENDING_SYSCALL</code>.</p></li><li><p>Recall that <code>mepc</code> stands for the program counter when the exception occurs, and the value of <code>mepc</code> is read into <code>proc_set[curr_proc_idx].mepc</code> in function <code>kernel_entry</code>. Therefore, line#9 says that, after the system call is done, the kernel should return to the instruction right after <code>ecall</code> (i.e., skip the 4-byte <code>ecall</code> instruction).</p></li><li><p>Line#10 tries to process the <code>SYS_SEND</code> or <code>SYS_RECV</code> system call for the current process, and line#11 finds the next process to schedule. You could also find <code>proc_try_syscall</code> in <code>proc_yield</code> because the scheduler will try to process a pending system call repeatedly until it succeeds.</p></li></ul><p>Read <code>proc_try_syscall()</code>, <code>proc_try_send()</code> and <code>proc_try_recv()</code>. There are only ~40 lines of code, but they gracefully handle inter-process communication. On the high level, if a process has a pending system call, <code>proc_try_syscall()</code> will retry the system call and, if succeeds, it will set the process status to <code>PROC_RUNNABLE</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>At this point, you have finished reading <code>grass/kernel.c</code>, including <code>kernel_entry</code>, <code>intr_entry</code>, <code>excp_entry</code>, <code>proc_yield</code>, <code>proc_try_syscall</code>, <code>proc_try_send</code> and <code>proc_try_recv</code>.</p></div><h3 id="introduce-process-sleep" tabindex="-1">Introduce process sleep <a class="header-anchor" href="#introduce-process-sleep" aria-label="Permalink to &quot;Introduce process sleep&quot;">​</a></h3><p>After getting familiar with the system call control flow, we now ask you to use system calls to introduce process sleep. As shown in <code>library/syscall/servers.h</code>, the <code>GPID_PROCESS</code> process in egos-2000 accepts 3 message types for spawning and terminating processes. Your job is to add a fourth message type <code>PROC_SLEEP</code> to <code>struct proc_request</code> so that the process which sends this message to <code>GPID_PROCESS</code> will sleep for a certain amount of time before being scheduled again. Start from a fresh copy of egos-2000, and add the following code as a new file <code>apps/user/sleep.c</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;app.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> usec_cnt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Start to sleep for </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> microseconds</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, usec_cnt);</span></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(usec_cnt);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Woke up again after </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> microseconds</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, usec_cnt);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Then run <code>make qemu</code> and <code>sleep</code> will be automatically added as a user command:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; make qemu</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>➜ /home/yunhao sleep</span></span>
<span class="line"><span>Start to sleep for 5000000 microseconds</span></span>
<span class="line"><span>Woke up again after 5000000 microseconds</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>However, you will see the second line of printing immediately after the first line because the <code>sleep</code> function in <code>library/syscall/servers.c</code> has not been implemented. You shall see the second line 5 seconds after the first line when you complete the following steps.</p><ol><li><p>Update the <code>struct proc_request</code> and the <code>sleep</code> function mentioned above so that this <code>sleep</code> function sends a <code>PROC_SLEEP</code> message to the <code>GPID_PROCESS</code> process.</p></li><li><p>In <code>apps/system/sys_proc.c</code>, add a case for <code>PROC_SLEEP</code> and put a debug printing there temporarily, so you know that <code>GPID_PROCESS</code> succeeds in receiving the message.</p></li><li><p>Add the <code>proc_sleep</code> function in <code>grass/kernel.c</code> to the grass interface (<code>struct grass</code> in <code>library/egos.h</code>), and initialize it in the <code>grass_entry</code> function of <code>grass/init.c</code>, just like <code>proc_alloc</code> and <code>proc_free</code>.</p></li><li><p>Invoke <code>grass-&gt;proc_sleep</code> in the <code>PROC_SLEEP</code> case you have just added in step 2. Then add a debug printing in the <code>proc_sleep</code> function of <code>grass/kernel.c</code>, so you know that <code>proc_sleep</code> is called by <code>GPID_PROCESS</code> with the correct <code>pid</code> and <code>usec</code> arguments.</p></li><li><p>Implement this <code>proc_sleep</code> function which should put process <code>pid</code> into sleep for <code>usec</code> microseconds. This involves a few modifications to the kernel.</p><ul><li>Add one or more fields to <code>struct process</code>, and initialize them in <code>proc_alloc()</code>.</li><li>Modify these fields for process <code>pid</code> in <code>proc_sleep()</code>. In addition to argument <code>usec</code>, you need <code>mtime_get()</code> which returns the clock time in 10^-7 second (on QEMU).</li><li>Modify the for-loop in <code>proc_yield()</code>, and schedule a process only if it is not sleeping given the fields in <code>struct process</code> and the latest clock time from <code>mtime_get()</code>.</li></ul></li><li><p>The kernel may now meet a situation where no process can be scheduled. You will need to handle this situation by replacing the <code>FATAL</code> in <code>proc_yield()</code> with your code.</p></li><li><p>Remove the debug printings. Run <code>sleep</code> again in the egos-2000 shell, and you shall see the <code>Woke up ...</code> printing 5 seconds after the first line of printing.</p></li></ol><h2 id="protect-the-os-memory" tabindex="-1">Protect the OS memory <a class="header-anchor" href="#protect-the-os-memory" aria-label="Permalink to &quot;Protect the OS memory&quot;">​</a></h2><p>By far, all the code we have seen runs in the so-called <strong>machine mode</strong> which means that the code can freely access the memory. However, user applications should not be able to freely read or write the memory. Otherwise, a malicious application can corrupt the memory of the kernel causing damages. On the high level, we now ask you to do 3 things:</p><ul><li>Specify the memory regions that code in the <strong>user mode</strong> is allowed to access.</li><li>Run the code of all user applications in the user mode instead of machine mode.</li><li>Terminate a user application if it triggers an exception by reading or writing the memory at an address outside of the allowed regions.</li></ul><h3 id="setup-a-pmp-region" tabindex="-1">Setup a PMP region <a class="header-anchor" href="#setup-a-pmp-region" aria-label="Permalink to &quot;Setup a PMP region&quot;">​</a></h3><p>Read through chapter 3.7 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a> for Physical Memory Protection (PMP), and then write your code in <code>earth/cpu_mmu.c</code>:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mmu_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Setup a PMP region for the whole 4GB address space. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrw pmpaddr0, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrw pmpcfg0, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Student&#39;s code goes here (System Call &amp; Protection). */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Replace the PMP region above with a NAPOT region 0x80200000 - 0x80400000</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * and set the permission for user mode access as r/w/x. */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Student&#39;s code ends here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Your code should overwrite the two CSRs <code>pmpaddr0</code> and <code>pmpcfg0</code>, so the 4GB region no longer takes effect, and is replaced by the 2MB region <code>[0x80200000, 0x80400000)</code>. As a result, you will only be able to choose <code>software TLB</code> when booting egos-2000 in the rest of P3.</p></div><p>Specifically, code running in the user mode <strong>cannot access any memory region by default</strong>. After you finish the PMP code above, code running in the user mode will be able to access one and only one memory region, <code>[0x80200000, 0x80400000)</code>. It contains the code, data, heap and stack of the current process (i.e., everything a user application needs).</p><p>However, PMP won&#39;t take any effects if we still run everything in the machine mode, so we need to switch privilege modes when switching the CPU context from the kernel back to a user application process.</p><h3 id="switch-privilege-modes" tabindex="-1">Switch privilege modes <a class="header-anchor" href="#switch-privilege-modes" aria-label="Permalink to &quot;Switch privilege modes&quot;">​</a></h3><p>You need to understand <code>mstatus.MPP</code>, and update <code>mstatus.MPP</code> in <code>proc_yield</code> accoding to the comments there. Recall that <code>mstatus.MPP</code> stands for bit#11 and bit#12 of <code>mstatus</code>:</p><p><img src="`+s+`" alt="Failed to load picture"></p><p>You will need to set these bits as <code>11</code> if the next process scheduled is a kernel process (i.e., <code>pid&lt;GPID_USER_START</code>), or set them as <code>00</code> for all the other processes. In RISC-V, 0 stands for user mode, and 3 (i.e., <code>11</code> in binary) stands for machine mode. To see how it works, we need to introduce more about what happens when entering and exiting the kernel.</p><p>Upon an interrupt or exception, the CPU enters the kernel, and it automatically switches the privilege mode to machine mode right before jumping to the handler function <code>trap_entry</code>. This allows the kernel to run in the machine mode and freely access the memory.</p><p>Upon executing <code>mret</code> in <code>grass/kernel.s</code>, the CPU exits the kernel, and <code>mret</code> will switch the privilege mode according to <code>mstatus.MPP</code>. Therefore, if we set <code>mstatus.MPP</code> to <code>00</code> in <code>proc_yield</code>, the process scheduled next will run in the user mode after this <code>mret</code>.</p><h3 id="kill-malicious-applications" tabindex="-1">Kill malicious applications <a class="header-anchor" href="#kill-malicious-applications" aria-label="Permalink to &quot;Kill malicious applications&quot;">​</a></h3><p>To test if you correctly set the PMP region and switch privilege modes, we have provided 2 malicious applications <code>crash1</code> and <code>crash2</code> under <code>apps/user</code>. The malicious applications would halt the whole operating system by corrupting the memory.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt;  make qemu</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>[CRITICAL] Choose a memory translation mechanism:</span></span>
<span class="line"><span>Enter 0: page tables</span></span>
<span class="line"><span>Enter 1: software TLB</span></span>
<span class="line"><span>[INFO] Software translation is chosen</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>[CRITICAL] Welcome to the egos-2000 shell!</span></span>
<span class="line"><span>➜ /home/yunhao crash1</span></span>
<span class="line"><span>_sbrk: heap grows too large</span></span>
<span class="line"><span>[FATAL] excp_entry: kernel got exception 7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Note that this <code>FATAL</code> happens at the end of function <code>excp_entry</code>. Your final task in P3 is to implement the following part of <code>excp_entry</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> excp_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Student&#39;s code goes here (System Call &amp; Protection | Virtual Memory). */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Kill the current process if curr_pid is a user application. */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Student&#39;s code ends here. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    FATAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;excp_entry: kernel got exception </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>After <code>excp_entry</code> kills the malicious applications gracefully, you should see the following.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Make sure to choose software TLB</span></span>
<span class="line"><span>&gt;  make qemu</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>&gt; /home/yunhao crash1</span></span>
<span class="line"><span>_sbrk: heap grows too large</span></span>
<span class="line"><span>[INFO] process 6 terminated with exception 7</span></span>
<span class="line"><span>&gt; /home/yunhao crash2</span></span>
<span class="line"><span>[INFO] process 7 terminated with exception 7</span></span>
<span class="line"><span>&gt; /home/yunhao</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>In other words, memory protection should work: the malicious applications running in the user mode trigger memory exceptions when trying to corrupt the memory. The kernel kills these malicious applications when handling such exceptions.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>In terms of OS concepts, you have learned about exception handling, system calls, privilege modes, and inter-process communication. In terms of code reading, you have completed all the code in <code>grass</code> and <code>library/syscall</code>. The <code>grass</code> layer is the kernel in egos-2000.</p><p>You will read <code>earth/cpu_mmu.c</code> in P4. You will read everything under <code>library/file</code> in P6. You will read <code>earth/dev_tty.c</code> and <code>earth/dev_disk.c</code> in P5. Then you will finish reading essentially all the code of egos-2000. We are halfway there!</p>`,71),h=[p];function r(o,c,d,k,u,g){return a(),i("div",null,h)}const b=e(l,[["render",r]]);export{E as __pageData,b as default};
