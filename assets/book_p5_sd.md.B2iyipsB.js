import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.CeQAp18V.js";const n="/assets/VT100.BOkLCgTb.jpg",t="/assets/arty_uart.CJvo0lN_.png",h="/assets/spi.CNWxwkhj.png",u=JSON.parse('{"title":"Serial Device Driver","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"book/p5_sd.md","filePath":"book/p5_sd.md"}'),l={name:"book/p5_sd.md"},r=e('<h1 id="serial-device-driver" tabindex="-1">Serial Device Driver <a class="header-anchor" href="#serial-device-driver" aria-label="Permalink to &quot;Serial Device Driver&quot;">​</a></h1><p>At this point, you have thoroughly studied the <strong>kernel</strong> (i.e., code under the <code>grass</code> directory of egos-2000), which is the most important component of an operating system. You have also studied <code>cpu_intr.c</code> and <code>cpu_mmu.c</code> under the <code>earth</code> directory holding the code for interrupts and virtual memory (i.e., CPU support in addition to user-level ISA that is critical to implementing the kernel).</p><p>In this project, you will further read <code>earth/dev_disk.c</code> and <code>earth/dev_tty.c</code>. The first file contains the driver for an SD card and the second file contains the driver for a terminal (i.e., keyboard input and screen output). While the 2 files combined have fewer than 200 lines of code, they are great examples of <strong>memory-mapped I/O</strong>, an important concept to learn.</p><h2 id="i-o-device-and-serial-bus" tabindex="-1">I/O device and serial bus <a class="header-anchor" href="#i-o-device-and-serial-bus" aria-label="Permalink to &quot;I/O device and serial bus&quot;">​</a></h2><p>Typically, a computer must be able to read keyboard input and print characters on a screen in order to interact with the outside world. In the old days, these functionalities are handled by a <em>terminal</em> device which is separate from the main body of a computer.</p><h3 id="terminal-and-uart" tabindex="-1">Terminal and UART <a class="header-anchor" href="#terminal-and-uart" aria-label="Permalink to &quot;Terminal and UART&quot;">​</a></h3><p>This photo of the VT100 video terminal was taken at the <a href="https://computerhistory.org/" target="_blank" rel="noreferrer">Computer History Museum</a>.</p><p><img src="'+n+`" alt="Failed to load picture"></p><p>A <em>serial bus</em> connects the CPU with a device, such as VT100, and transfers data between the two. The most commonly used serial bus is likely the <strong>Universal Serial Bus</strong> (USB). USB is powerful but complex: there are at least 9 variants of USB connectors with various numbers of hardware pins, according to <a href="https://en.wikipedia.org/wiki/USB_hardware#Connectors" target="_blank" rel="noreferrer">this Wikipedia page</a>.</p><p>We start by introducing the much simpler UART serial bus which has only 2 hardware pins. UART stands for <strong>Universal Asynchronous Receiver/Transmitter</strong> and thus one hardware pin is used to <em>receive</em> bytes while the other is used to send (i.e., <em>transmit</em>) bytes.</p><p>When pressing a key on the keyboard, the terminal sends the corresponding character as a byte through the UART serial bus to the CPU and the operating system can read this byte through the <em>Receiver</em> hardware pin. When the operating system prints a character, it sends a byte through the <em>Transmitter</em> pin to the terminal. <em>Asynchronous</em> here means that electrical signals for keyboard input and screen output on the two pins are not related.</p><p>The code below shows how an operating system could use UART to control a terminal.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UART_BASE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10010000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SIFIVE_UART_TXDATA</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SIFIVE_UART_RXDATA</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UL</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uart_getc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, SIFIVE_UART_RXDATA)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 /* Read memory address 0x10010004 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uart_putc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, SIFIVE_UART_TXDATA) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /* Read memory address 0x10010000 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, SIFIVE_UART_TXDATA) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Write memory address 0x10010000 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>In short, the CPU provides two special memory addresses <code>0x10010000</code> and <code>0x10010004</code> for sending and receiving bytes through UART. When receiving a byte, <code>uart_getc</code> reads 4 bytes from <code>0x10010004</code> and the most significant bit indicates whether a byte is received. If the most significant bit is 1, the lowest byte is the byte read from UART (i.e., what is pressed on the terminal keyboard). When sending a byte, <code>uart_putc</code> first waits for the UART bus to become idle (i.e., UART has finished sending the previous byte) and then writes to address <code>0x10010000</code> with the byte to be printed on the terminal screen.</p><p>The code above looks very simple because most of the complexities have been hidden by the hardware. For example, when running egos-2000 on the Arty FPGA board and using a laptop (e.g., the <code>screen</code> command in MacOS) as the terminal, the <em>UART/USB bridge</em> black chip shown below will convert the electrical signals between UART and USB, so egos-2000 can use the simple UART serial bus and avoid the complexity of USB.</p><p><img src="`+t+'" alt="Failed to load picture"></p><p>Still, the code above is a concrete example of <strong>memory-mapped I/O</strong>. Specifically, hardware manufacturers can define special memory regions that are used to control I/O devices, and different manufacturers can use different regions. Indeed, egos-2000 supports both QEMU and the Arty board which use different regions for the memory-mapped UART terminal. You can see such differences in <code>earth/dev_tty.c</code>: the macros with prefix <code>SIFIVE</code> and <code>LITEX</code> correspond to two different hardware manufacturers.</p><p>For Sifive, you can find the <code>0x10010000</code> address and the <code>TXDATA/RXDATA</code> offsets defined in Chapters 13.2 and 13.3 of their <a href="assets/fu540-c000-manual-v1p4.pdf">CPU reference manual</a>, which is followed by QEMU.</p><h3 id="sd-card-and-spi" tabindex="-1">SD card and SPI <a class="header-anchor" href="#sd-card-and-spi" aria-label="Permalink to &quot;SD card and SPI&quot;">​</a></h3><p>In addition to a terminal, a computer typically needs a disk that stores blocks of data even when the computer is powered off. In this project, we use an <a href="https://en.wikipedia.org/wiki/SD_card" target="_blank" rel="noreferrer">SD card</a> as the disk device and you will play with the SD card driver code in egos-2000.</p><p>An SD card is connected to the CPU through the <strong>Serial Peripheral Interface</strong> (SPI). SPI has 4 hardware pins, a bit more complex than UART. The picture below illustrates these hardware pins and the picture is from <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" target="_blank" rel="noreferrer">this Wikipedia page</a>.</p><p><img src="'+h+`" alt="Failed to load picture"></p><p>Specifically, consider the CPU as the &quot;SPI Main&quot; and the SD card device as the &quot;SPI Sub&quot;. Each side has 4 hardware pins and their functionalities are described below.</p><ul><li><strong>Chip Select (CS)</strong> is used to reset the SD card before using it.</li><li><strong>Serial Clock (SCLK)</strong> provides clock signals from the CPU (e.g., 20MHz).</li><li><strong>Main Out Sub In (MOSI)</strong> is used by the CPU to send bytes to the SD card.</li><li><strong>Main In Sub Out (MISO)</strong> is used by the SD card to send bytes to the CPU.</li></ul><p>Similar to UART, the CPU provides memory-mapped I/O regions for communicating with the SD card through SPI. Different from UART, the SPI Main and SPI Sub <em>exchange</em> the bytes in their Shift Register during each communication. The code below explains how it works.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rxdata;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Send a byte through MOSI */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SPI_BASE, SIFIVE_SPI_TXDATA) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SPI_BASE, SIFIVE_SPI_TXDATA) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Receive a byte through MISO */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((rxdata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SPI_BASE, SIFIVE_SPI_RXDATA)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(rxdata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>We omitted the macro definitions in the code for the memory-mapped I/O regions, and you can find them in egos-2000 or Chapter 16 of this <a href="assets/fu540-c000-manual-v1p4.pdf">CPU reference manual</a>.</p><p>The first <code>while</code> loop is similar to the waiting logic in <code>uart_putc</code>. After sending a byte, the SPI bus immediately receives a byte from the SD card as the return value of <code>spi_exchange</code>. While <code>spi_exchange</code> uses the <code>MOSI</code> and <code>MISO</code> pins, the <code>spi_set_clock</code> function controls the clock signal sent out through the <code>SCLK</code> pin from the CPU.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_set_clock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> freq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    #define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CPU_CLOCK_RATE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100000000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 100MHz */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div                         </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPU_CLOCK_RATE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> freq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SPI_BASE, LITEX_SPI_CLKDIV) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>As an exercise, read the <code>sd_init</code> function in <code>earth/dev_disk.c</code> in which you will see how <code>spi_set_clock</code> is used as well as some other initialization logic.</p><p>We have seen how to exchange a single byte between the CPU and the SD card. In the SD card standard, every <strong>SD card command</strong> has 6 bytes, so the operating system could ask the SD card to complete a particular task by sending the corresponding 6-byte command. Such commands form the basis of the SD card driver code in egos-2000.</p><h3 id="run-an-sd-card-command" tabindex="-1">Run an SD card command <a class="header-anchor" href="#run-an-sd-card-command" aria-label="Permalink to &quot;Run an SD card command&quot;">​</a></h3><p>Given a 6-byte command, the <code>sd_exec_cmd</code> function sends this command to the SD card and then waits for a reply with a timeout.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sd_exec_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    #define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TIME_OUT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reply, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TIME_OUT; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((reply </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reply;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>With the <code>sd_exec_cmd</code> helper function, we can start to read some SD card driver code.</p><h2 id="sd-card-driver" tabindex="-1">SD card driver <a class="header-anchor" href="#sd-card-driver" aria-label="Permalink to &quot;SD card driver&quot;">​</a></h2><p>An SD card <strong>block</strong> is typically 512 bytes. When reading or writing an SD card, the operating system will read or write whole blocks. This is different from a terminal device which reads or writes in the granularity of bytes. Many operating systems thus distinguish <em>block device</em> and <em>character device</em> as two different device types.</p><h3 id="read-an-sd-card-block" tabindex="-1">Read an SD card block <a class="header-anchor" href="#read-an-sd-card-block" aria-label="Permalink to &quot;Read an SD card block&quot;">​</a></h3><p>The <code>sd_read</code> function reads a block from the SD card into memory address <code>dst</code> while the <code>offset</code> argument specifies which block to read. For example, if <code>offset</code> is 0, <code>sd_read</code> will read the starting block on the SD card.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sd_read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Wait until SD card is not busy */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Send read request with cmd17 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cmd17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">51</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sd_exec_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cmd17) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FATAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CMD17 has non-zero reply&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Wait for the data packet and ignore the 2-byte checksum */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 512</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>On the high level, the code above involves the following steps.</p><ul><li>Wait for the SD card device to become idle.</li><li>Send command <code>cmd17</code> to the SD card. Out of this command&#39;s 6 bytes, 4 bytes encode a block number (i.e., <code>offset</code>) indicating which block to read.</li><li>Wait for the SD card to be ready to send back the 512 bytes of data.</li><li>Receive 512 bytes from the SD card as the block data and 2 bytes as the checksum.</li></ul><p>As an exercise, please also read the <code>sd_write</code> function in <code>earth/dev_disk.c</code> which writes a block of data into the SD card with a similar logic.</p><h3 id="multi-block-read-and-write" tabindex="-1">Multi-block read and write <a class="header-anchor" href="#multi-block-read-and-write" aria-label="Permalink to &quot;Multi-block read and write&quot;">​</a></h3><p>You will implement an improved version of the SD card driver. The current driver uses SD card command 17 and 24 for reading and writing a single block, and the <code>disk_read/write</code> functions will use command 17 and 24 multiple times within a loop.</p><p>The SD card standard also provides command 18 and 25 for reading and writing <em>multiple</em> consecutive blocks. Your job is to replace the loops in <code>disk_read</code> and <code>disk_write</code> with your own SD card driver code using SD command 18 and 25. The details of command 18 and 25 can be found in <a href="http://elm-chan.org/docs/mmc/mmc_e.html" target="_blank" rel="noreferrer">this blog</a> which contains some useful tables and figures. You can certainly find other online materials about these SD card commands.</p><p>After your code modifications, egos-2000 should be able to run normally on both QEMU and the Arty board since both of them provide an SD card device through the SPI bus. In addition, it could be very useful to write some unit tests for your driver code. For example, egos-2000 only uses the first 4MB of the SD card, and you can test your driver code with the rest of the SD card capacity. You could run your test code right after the <code>disk_init()</code> within <code>earth/boot.c</code>.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have learned about <strong>serial bus</strong> and <strong>memory-mapped I/O</strong> by reading through the device driver code in egos-2000. You have also written some driver code yourself for reading and writing SD card blocks which is the basis for the next project, file system.</p>`,49),p=[r];function k(d,o,c,E,g,y){return a(),i("div",null,p)}const b=s(l,[["render",k]]);export{u as __pageData,b as default};
