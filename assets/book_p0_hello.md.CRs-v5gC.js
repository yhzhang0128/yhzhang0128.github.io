import{s,c as e,o as i,a2 as a}from"./chunks/framework.CeQAp18V.js";const n=a(`<h1 id="hello-world" tabindex="-1">Hello, World! <a class="header-anchor" href="#hello-world" aria-label="Permalink to &quot;Hello, World!&quot;">​</a></h1><p>This project helps you understand the following C program.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Specifically, you will learn about 3 types of CPU instructions (integer computation, control transfer, memory access) and 4 types of memory regions (code, data, heap, stack), which are fundamental to every computer program.</p><p><strong>Prerequisites:</strong> an entry-level systems course equivalent to <a href="https://www.cs.cornell.edu/courses/cs3410/2024fa/" target="_blank" rel="noreferrer">Cornell CS3410</a> or <a href="http://www.cs.cmu.edu/~213/" target="_blank" rel="noreferrer">CMU 15-213</a> is typically required before learning OS. This project aims at revisiting the concepts of CPU instructions and memory regions instead of taking the place of an entry-level course.</p><h2 id="get-started" tabindex="-1">Get started <a class="header-anchor" href="#get-started" aria-label="Permalink to &quot;Get started&quot;">​</a></h2><p>Follow the instructions of step1 and step2 in <a href="https://github.com/yhzhang0128/egos-2000/blob/main/USAGES.md" target="_blank" rel="noreferrer">USAGES.md</a>. After you can compile egos-2000 and run it on QEMU, switch to the <code>hello</code> branch by <code>git checkout hello</code>. Run this branch by <code>make qemu</code> and then you will see the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-------- Compile Hello, World! --------</span></span>
<span class="line"><span>riscv-none-elf-gcc -march=rv32ima_zicsr -mabi=ilp32 -Wl,--gc-sections -ffunction-sections -fdata-sections -fdiagnostics-show-option -fno-builtin hello.s hello.c -Thello.lds -nostdlib -lc -lgcc -o hello.elf</span></span>
<span class="line"><span>riscv-none-elf-objdump --source --all-headers --demangle --line-numbers --wide hello.elf &gt; hello.lst</span></span>
<span class="line"><span>riscv-none-elf-objcopy -O binary hello.elf hello.bin</span></span>
<span class="line"><span>-------- Run Hello-World on QEMU --------</span></span>
<span class="line"><span>qemu-system-riscv32 -nographic -machine virt -smp 1 -bios hello.bin</span></span>
<span class="line"><span>Hello, World!</span></span></code></pre></div><p>The code in this branch prints <code>Hello, World!</code> on the screen and stalls. You can exit QEMU by typing <code>ctrl+a</code> and then <code>x</code>, after which you will see <code>QEMU: Terminated</code>.</p><p>Next, we explain the code in this <code>hello</code> branch which gives concrete examples of CPU instructions (integer computation, control transfer, memory access) and memory regions (code, data, heap, stack). After the explanation, you will start from this code and implement the <code>printf</code> function as an exercise.</p><h2 id="instructions-and-memory" tabindex="-1">Instructions and memory <a class="header-anchor" href="#instructions-and-memory" aria-label="Permalink to &quot;Instructions and memory&quot;">​</a></h2><h3 id="before-main" tabindex="-1">Before <code>main()</code> <a class="header-anchor" href="#before-main" aria-label="Permalink to &quot;Before \`main()\`&quot;">​</a></h3><p>Let&#39;s start with the first two lines of <code>hello.lds</code>.</p><div class="language-lds vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">lds</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>OUTPUT_ARCH(&quot;riscv&quot;)</span></span>
<span class="line"><span>ENTRY(_start)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>The first line says that the output architecture for this computer program is RISC-V. This book will focus on RISC-V since it is widely used for education, but there also exist other influential CPU architectures such as ARM and Intel x86. The second line says that the entry point of this program is <code>_start</code>, defined in <code>hello.s</code>. We will move our attention to <code>hello.s</code> and ignore the rest of <code>hello.lds</code> for now.</p><p>According to <code>_start</code> in <code>hello.s</code>, the first two CPU instructions in this program are</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">li </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80400000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> main</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>The <code>li</code> instruction loads the 4-byte integer <code>0x80400000</code> to the stack pointer register <code>sp</code>. <code>li</code> is an example of <strong>integer computation</strong> instructions because it modifies a register with an integer. Other examples of integer computation include addition, multiplication, division, bitwise shift, bitwise AND/OR/XOR operations, etc.</p><p>After setting <code>sp</code>, the <code>call</code> instruction transfers the control to <code>main()</code> in <code>hello.c</code>. The <code>call</code> instruction is an example of <strong>control transfer</strong> instructions, and it does two things: (1) point the program counter to the first instruction of <code>main()</code>; (2) set the <code>ra</code> register to the address of <code>call _end</code> in <code>hello.s</code>, which is the instruction next to <code>call main</code>. Intuitively, <code>sp</code> specifies the memory that <code>main()</code> can use on the stack and <code>ra</code> specifies the return address, i.e., the program counter after <code>main()</code> returns. We make this intuition concrete by reading the code of <code>main()</code>.</p><h3 id="in-main" tabindex="-1">In <code>main()</code> <a class="header-anchor" href="#in-main" aria-label="Permalink to &quot;In \`main()\`&quot;">​</a></h3><p>The C code of <code>main()</code> in <code>hello.c</code> is simple:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello, World!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    terminal_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>After <code>make</code>, you can find the CPU instructions for <code>main()</code> in <code>hello.lst</code>:</p><div class="language-lst vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">lst</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>80000078 &lt;main&gt;:</span></span>
<span class="line"><span>main():</span></span>
<span class="line highlighted"><span>80000078:   fe010113            addi    sp,sp,-32</span></span>
<span class="line highlighted"><span>8000007c:   00112e23            sw  ra,28(sp)</span></span>
<span class="line highlighted"><span>80000080:   00812c23            sw  s0,24(sp)</span></span>
<span class="line"><span>80000084:   02010413            addi    s0,sp,32</span></span>
<span class="line"><span>80000088:   800007b7            lui a5,0x80000</span></span>
<span class="line"><span>8000008c:   0b878793            addi    a5,a5,184 # 800000b8 &lt;main+0x40&gt;</span></span>
<span class="line"><span>80000090:   fef42623            sw  a5,-20(s0)</span></span>
<span class="line"><span>80000094:   00f00593            li  a1,15</span></span>
<span class="line"><span>80000098:   fec42503            lw  a0,-20(s0)</span></span>
<span class="line"><span>8000009c:   f75ff0ef            jal 80000010 &lt;terminal_write&gt;</span></span>
<span class="line"><span>800000a0:   00000793            li  a5,0</span></span>
<span class="line"><span>800000a4:   00078513            mv  a0,a5</span></span>
<span class="line highlighted"><span>800000a8:   01c12083            lw  ra,28(sp)</span></span>
<span class="line highlighted"><span>800000ac:   01812403            lw  s0,24(sp)</span></span>
<span class="line highlighted"><span>800000b0:   02010113            addi    sp,sp,32</span></span>
<span class="line highlighted"><span>800000b4:   00008067            ret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>There are 16 instructions for <code>main</code> starting at memory address <code>0x80000078</code> and each of them occupies 4 bytes of memory. Therefore, the <code>call main</code> instruction in <code>hello.s</code> sets the program counter to <code>0x80000078</code> which points to an <code>addi</code> instruction. The binary form of this <code>addi</code> instruction is <code>0xfe010113</code> and such binary encoding is explained in the <a href="assets/riscv-unprivileged-20240411.pdf">RISC-V Instruction Set Manual</a>. For our purpose, we can ignore the binary encodings and focus on the instructions themselves. Let&#39;s start by reading the 7 highlighted instructions.</p><h4 id="prologue-and-epilogue" tabindex="-1">Prologue and epilogue <a class="header-anchor" href="#prologue-and-epilogue" aria-label="Permalink to &quot;Prologue and epilogue&quot;">​</a></h4><p>The two <code>addi</code> instructions at address <code>0x80000078</code> and <code>0x800000b0</code> add integers <code>-32</code> and <code>32</code> to the <code>sp</code> register, which indicates that the 32-byte memory region <code>[0x80400000 - 32, 0x80400000)</code> is used for the stack of <code>main()</code>. The <code>ret</code> will cause a control transfer to the instruction pointed by <code>ra</code>, i.e., the <code>call _end</code> in <code>hello.s</code> as we explained earlier. Such usage of <code>sp</code> and <code>ra</code> is the common structure of every function in C.</p><p>Note that <code>ra</code> should still hold the address of <code>call _end</code> when executing <code>ret</code>, which is ensured by these two instructions:</p><div class="language-lst vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lst</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>8000007c:   00112e23            sw  ra,28(sp)</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>800000a8:   01c12083            lw  ra,28(sp)</span></span></code></pre></div><p><code>28(sp)</code> means adding 28 to <code>sp</code> as a memory address. Since <code>sp</code> equals <code>0x80400000 - 32</code>, the <code>sw</code> instruction stores the 4 bytes of <code>ra</code> into memory region <code>[0x80400000 - 4, 0x80400000)</code> and the <code>lw</code> loads 4 bytes from the region back to <code>ra</code>. As long as this 4-byte region is unmodified, <code>ra</code> can be freely modified during the execution of <code>main()</code>.</p><p>These are examples of <strong>memory access</strong> instructions and another example is <code>lb/sb</code> which loads/stores one byte from/to the memory while <code>lw/sw</code> loads/stores 4 bytes altogether.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Till this point, we have seen examples of all the 3 types of CPU instructions (integer computation, control transfer, memory access) that constitute the <strong>user-level instructions</strong> of RISC-V. P0 and P1 will only use user-level instructions. Starting from P2, you will see more instructions and registers that are needed for operating systems.</p></div><h4 id="first-line-of-main" tabindex="-1">First line of <code>main()</code> <a class="header-anchor" href="#first-line-of-main" aria-label="Permalink to &quot;First line of \`main()\`&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello, World!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>is compiled to the following 4 instructions.</p><div class="language-lst vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">lst</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>80000084:   02010413            addi    s0,sp,32</span></span>
<span class="line"><span>80000088:   800007b7            lui a5,0x80000</span></span>
<span class="line"><span>8000008c:   0b878793            addi    a5,a5,184 # 800000b8 &lt;main+0x40&gt;</span></span>
<span class="line"><span>80000090:   fef42623            sw  a5,-20(s0)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>lui</code> stands for <strong>l</strong>oad-<strong>u</strong>pper-<strong>i</strong>mmediate which means that the upper 20 bits of <code>a5</code> are set to <code>0x80000</code> while the lower 12 bits are set to 0. Therefore, these 4 instructions (1) set <code>s0</code> to <code>0x80400000</code>; (2) set <code>a5</code> to <code>0x800000b8</code>; (3) store the 4-byte of <code>0x800000b8</code> at memory address <code>0x80400000 - 20</code>. This means two things:</p><ol><li><p>The compiler puts the <code>&quot;Hello, World!\\n\\r&quot;</code> string at memory address <code>0x800000b8</code>.</p></li><li><p>The compiler decides that <code>msg</code>, as a local variable of <code>main()</code>, occupies the 4 bytes of memory starting at <code>0x80400000 - 20</code> in the 32-byte stack of <code>main()</code>.</p></li></ol><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>This is a good point to revise the concept of <strong>pointers</strong>. In C, a <code>char</code> is simply one byte storing the ASCII encoding of a character. For example, the ASCII encoding for &quot;H&quot; and &quot;e&quot; are 72 and 101 respectively so that memory address <code>0x800000b8</code> holds 72 and <code>0x800000b9</code> holds 101. The type of <code>msg</code>, namely <code>char*</code>, is called <strong>char pointer</strong>, meaning that variable <code>msg</code> holds the memory address of a char. This book targets 32-bit CPUs so that every memory address is represented by 4 bytes (i.e., all pointers hold 4 bytes). One can <strong>dereference</strong> the <code>msg</code> pointer with syntax <code>*msg</code>. For example, <code>*msg == &#39;H&#39;</code> and <code>*(msg + 1) == &#39;e&#39;</code>.</p></div><h4 id="second-and-third-line" tabindex="-1">Second and third line <a class="header-anchor" href="#second-and-third-line" aria-label="Permalink to &quot;Second and third line&quot;">​</a></h4><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    terminal_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>are compiled to the following 5 instructions.</p><div class="language-lst vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">lst</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>80000094:   00f00593            li  a1,15</span></span>
<span class="line"><span>80000098:   fec42503            lw  a0,-20(s0)</span></span>
<span class="line"><span>8000009c:   f75ff0ef            jal 80000010 &lt;terminal_write&gt;</span></span>
<span class="line"><span>800000a0:   00000793            li  a5,0</span></span>
<span class="line"><span>800000a4:   00078513            mv  a0,a5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>In short, registers <code>a0</code> and <code>a1</code> hold the first two arguments when calling a function, and <code>a0</code> further holds the return value. Therefore, <code>a1</code> is set to 15 and <code>a0</code> is set to <code>0x800000b8</code> by loading 4 bytes from address <code>0x80400000 - 20</code>. <code>jal</code> is an alias of <code>call</code> and the first instruction of <code>terminal_write</code> is at address <code>0x80000010</code>. After <code>terminal_write</code> returns, <code>a0</code> is set to 0 as the return value of <code>main()</code>. It is possible to do <code>li a0,0</code> directly without touching <code>a5</code> if the compiler does more optimizations.</p><h3 id="in-terminal-write" tabindex="-1">In <code>terminal_write()</code> <a class="header-anchor" href="#in-terminal-write" aria-label="Permalink to &quot;In \`terminal_write()\`&quot;">​</a></h3><p>For <code>terminal_write()</code>, we only explain the C code and you can read all its instructions in <code>hello.lst</code> as an exercise.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> terminal_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>For P0, it is enough to know that writing a byte to this special address <code>0x10000000</code> will print a character on the screen. P5 will introduce device I/O with details.</p><p><code>*(char*)(0x10000000)</code> converts <code>0x10000000</code> into a char pointer and then dereferences the pointer, so it stands for the byte at memory address <code>0x10000000</code>.</p><h3 id="code-data-and-stack" tabindex="-1">Code, data and stack <a class="header-anchor" href="#code-data-and-stack" aria-label="Permalink to &quot;Code, data and stack&quot;">​</a></h3><p>We have examined the two functions in this program. We now review the memory regions touched by the CPU instructions. Let&#39;s start with the following part of <code>hello.lst</code>:</p><div class="language-lst vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lst</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Sections:</span></span>
<span class="line"><span>Idx Name              Size      VMA       LMA       File off  Algn  Flags</span></span>
<span class="line"><span>  0 .init             0000000c  80000000  80000000  00001000  2**3  CONTENTS, ALLOC, LOAD, READONLY, CODE</span></span>
<span class="line"><span>  1 .text             000000a8  80000010  80000010  00001010  2**3  CONTENTS, ALLOC, LOAD, READONLY, CODE</span></span>
<span class="line"><span>  2 .rodata           00000010  800000b8  800000b8  000010b8  2**3  CONTENTS, ALLOC, LOAD, READONLY, DATA</span></span></code></pre></div><p>A <strong>section</strong> is simply a memory region specified by a starting address and its size.</p><p>The <code>.init</code> section starts at <code>0x80000000</code> and holds the three instructions in <code>hello.s</code>. By default, <code>0x80000000</code> is used to initialize the program counter in QEMU. The <code>.text</code> section holds instructions for <code>terminal_write()</code> and <code>main()</code> starting at <code>0x80000010</code> and ending at <code>0x800000b8</code>. Together, <code>.init</code> and <code>.text</code> form the <strong>code</strong> region of this program.</p><p>The 16 bytes starting at <code>0x800000b8</code> form the <strong>data</strong> region of this program. The data region would typically contain 3 sections:</p><ol><li><code>.rodata</code> holds read-only data such as the <code>&quot;Hello, World!\\n\\r&quot;</code> string.</li><li><code>.data</code> holds global variables with non-zero initial values.</li><li><code>.bss</code> holds global variables with zero as their initial value.</li></ol><p>This simple program does not have any global variables, so we only see <code>.rodata</code>. The end of <code>.rodata</code> is <code>0x800000c8</code>, which is the start of the <strong>heap</strong> region. You will learn about heap later in the <a href="#dynamic-memory-allocation">dynamic memory allocation</a> section.</p><p>Lastly, the <strong>stack</strong> region starts at <code>0x80400000</code> and grows <strong>down</strong>. Specifically, the stack for <code>main</code> is <code>[0x80400000 - 32, 0x80400000)</code> and the stack for <code>terminal_write</code> is the 48-byte region <code>[0x80400000 - 32 - 48, 0x80400000 - 32)</code>. The choice of <code>0x80400000</code> is not mandatory and it is possible to set <code>sp</code> as a different value in <code>hello.s</code>.</p><h2 id="formatted-output" tabindex="-1">Formatted output <a class="header-anchor" href="#formatted-output" aria-label="Permalink to &quot;Formatted output&quot;">​</a></h2><p>The <code>terminal_write</code> function takes a string and prints it on the screen, but we may further wish to print integers, pointers in hexadecimal format, etc. We thus introduce the <code>printf</code> function which converts a format into a string and prints it on the screen.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is a number&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1234</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is a string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;abcd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is awesome!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;egos&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>These examples show that <code>printf</code> takes a string as the first argument which has special meanings: <code>%d</code> and <code>%s</code> mean placeholders for integers and strings. For example, the last <code>printf</code> would print &quot;egos-2000 is awesome!&quot; according to the 3 arguments.</p><p>Uncomment the <code>printf</code> from the <code>main</code> function of <code>hello.c</code>, and uncomment functions <code>format_to_str</code> and <code>printf</code>. Do <code>make qemu</code> again and you will see the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Hello, World!</span></span>
<span class="line"><span>egos-2000 is awesome!</span></span></code></pre></div><p>Let&#39;s start by reading the first 3 lines of this code block:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;string.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // for strlen() and strcat()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // for itoa()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdarg.h&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // for va_start(), va_end() and va_arg()</span></span></code></pre></div><p>Intuitively, the code includes part of the <strong>C standard library</strong>. For example, <code>strlen</code> takes a string and returns its length, and the code of <code>strlen</code> is provided by the <code>string.h</code> library in the C compiler, so you don&#39;t need to write it yourself. Similarly, <code>strcat</code> in the <code>string.h</code> library concatenates two strings into a single one. And the <code>itoa</code> in <code>stdlib.h</code> converts an integer to a string in ASCII encoding (i.e., <strong>i</strong>nteger-<strong>to</strong>-<strong>A</strong>SCII).</p><p>Lastly, <code>stdarg.h</code> provides <code>va_start</code>, <code>va_end</code>, and <code>va_arg</code>, where <code>va</code> means variable argument (i.e., the argument list of <code>printf</code> does not have a fixed length so that different invocations of <code>printf</code> can take different numbers of arguments). In <code>format_to_str</code>, the <code>va_arg(args, int)</code> reads an <code>int</code>-type argument from the list and the <code>itoa</code> converts the integer to a string, appending to the end of the <code>out</code> string.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Read the assembly code of <code>format_to_str</code> and <code>printf</code> in <code>hello.lst</code> yourself. You can skip library functions like <code>strlen</code> or <code>strcat</code>, and focus on instructions within these two functions. You will get a <strong>precise understanding</strong> by connecting the C code with the CPU instructions, which verbal explanations cannot give to you. For example, you will see how <code>va_arg</code> is compiled to a few load and store instructions without doing any function calls.</p></div><p>After gaining a precise understanding of <code>format_to_str</code> and <code>printf</code>, you need to modify <code>format_to_str</code> so that the code below works correctly.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is character $&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is character 0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">48</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%x</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is integer 1234 in hexadecimal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1234</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is the maximum of unsigned int&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FFFFFFFF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is the hexadecimal address of the hello-world string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%llu</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is the maximum of unsigned long long&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FFFFFFFFFFFFFFFF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The expected output is shown below and the hexadecimal address of the hello-world string might be different given different compilers.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ is character $</span></span>
<span class="line"><span>0 is character 0</span></span>
<span class="line"><span>4d2 is integer 1234 in hexadecimal</span></span>
<span class="line"><span>4294967295 is the maximum of unsigned int</span></span>
<span class="line"><span>0x800029f8 is the hexadecimal address of the hello-world string</span></span>
<span class="line"><span>18446744073709551615 is the maximum of unsigned long long</span></span></code></pre></div><h2 id="dynamic-memory-allocation" tabindex="-1">Dynamic memory allocation <a class="header-anchor" href="#dynamic-memory-allocation" aria-label="Permalink to &quot;Dynamic memory allocation&quot;">​</a></h2><p>The <code>char buf[512]</code> in <code>printf</code> allocates 512 bytes on the stack of <code>printf</code> to hold the output string generated by <code>format_to_str</code>. However, the output string can be longer than 512 bytes and, during compile time, the length of the output string is usually unknown. This leads to the need for dynamic memory allocation:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ...) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    va_list args;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    va_start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, format);</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> format_to_str_len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(format, args);</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">buf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    format_to_str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf, format, args);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    va_end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    terminal_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">strlen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf));</span></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    free</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>In this last part of P0, you will implement the <code>format_to_str_len</code> function which calculates the length of the output string based on <code>format</code> and <code>args</code>. After <code>malloc</code>, pointer <code>buf</code> holds an address such that the <code>len</code> bytes starting at this address can be freely used. After invoking <code>free</code>, this <code>len</code>-byte region can no longer be used.</p><h3 id="heap" tabindex="-1">Heap <a class="header-anchor" href="#heap" aria-label="Permalink to &quot;Heap&quot;">​</a></h3><p>Before explaining more about <code>malloc</code> and <code>free</code>, we explain the heap memory region with the code below which you need to uncomment from <code>hello.c</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">extern</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> __heap_start, __heap_end;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> brk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__heap_start;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _sbrk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (brk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__heap_end) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        terminal_write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_sbrk: heap grows too large</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\r\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">29</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old_brk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> brk;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    brk </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> size;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> old_brk;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>__heap_start</code> and <code>__heap_end</code> are defined in <code>hello.lds</code>: <code>__heap_start</code> is the end of the data region (i.e., the end of the <code>.bss</code> section) while <code>__heap_end</code> is hard-coded to <code>0x80200000</code>, just like the initial stack pointer is hard-coded to <code>0x80400000</code>.</p><p>The purpose here is to ensure that the heap and stack do not overlap when the heap grows up and the stack grows down, which spawns the concept of <strong>break pointer</strong> (i.e., the <code>brk</code> variable above pointing to the end of the heap). As long as the break pointer is lower than the stack pointer, the stack and the heap do not overlap. We simply assume that the stack pointer <code>sp</code> is never lower than <code>0x80200000</code> (i.e., the stack size is never larger than 2MB) and the <code>brk</code> variable is never greater than <code>0x80200000</code>.</p><h3 id="malloc-and-free" tabindex="-1">Malloc and free <a class="header-anchor" href="#malloc-and-free" aria-label="Permalink to &quot;Malloc and free&quot;">​</a></h3><p>The initial heap size is 0 since <code>brk</code> is initialized as <code>__heap_start</code> and the heap region is defined as <code>[__heap_start, brk)</code>. Say <code>malloc(512)</code> is the first time invoking <code>malloc</code>. Three things will happen within <code>malloc</code>:</p><ol><li>Invoke <code>_sbrk</code> with an argument greater than <code>512</code>, say <code>4096</code> (i.e., 4KB);</li><li>With the return value of <code>_sbrk</code>, initialize some data structures in the 4KB region;</li><li>With the data structures, find <code>512</code> bytes in this heap region and return its address.</li></ol><p>Say <code>malloc(32)</code> is invoked next. It is likely that <code>malloc</code> can find 32 bytes using the data structures without having to invoke <code>_sbrk</code> again and increase the heap. When <code>free</code> is invoked, the data structures are updated so that the freed memory can be reused by a later <code>malloc</code>. For example, multiple invocations of <code>printf</code> may use the same memory region to hold the output string (i.e., <code>malloc</code> returns the same pointer multiple times).</p><p>The data structure operations for <code>malloc</code> and <code>free</code> are implemented in the <code>stdlib.h</code> library from the C compiler so that you don&#39;t have to know the details, just like you don&#39;t have to know the details of <code>itoa</code> or <code>strcat</code>. However, you are more than welcome to design your own data structures and write your own <code>malloc</code> and <code>free</code> functions.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have finished reading <code>library/libc</code> in egos-2000. You also get the intuition behind <code>library/elf</code> which initializes the 4 memory regions for a program, given the executable binary of this program in <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noreferrer">the ELF format</a>.</p>`,89),t=[n],d=JSON.parse('{"title":"Hello, World!","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"book/p0_hello.md","filePath":"book/p0_hello.md"}'),l={name:"book/p0_hello.md"},c=Object.assign(l,{setup(o){return s(143),(r,p)=>(i(),e("div",null,t))}});export{d as __pageData,c as default};
