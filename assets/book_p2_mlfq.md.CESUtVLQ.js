import{_ as e}from"./chunks/mstatus.AnuZ0eMl.js";import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.CeQAp18V.js";const t="/assets/p2_timer.Dtw002EP.png",l="/assets/mie.CfvvRWxH.png",r="/assets/interrupt.Bl3qOwz5.png",f=JSON.parse('{"title":"Preemptive Scheduler","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"book/p2_mlfq.md","filePath":"book/p2_mlfq.md"}'),o={name:"book/p2_mlfq.md"},p=n('<h1 id="preemptive-scheduler" tabindex="-1">Preemptive Scheduler <a class="header-anchor" href="#preemptive-scheduler" aria-label="Permalink to &quot;Preemptive Scheduler&quot;">​</a></h1><p>This project helps you understand the <strong>scheduler</strong> of egos-2000. Most of the egos-2000 scheduler logic is in the <code>proc_yield</code> function from <code>grass/kernel.c</code> which, similar to the <code>thread_yield</code> function in P1, chooses the next thread to be scheduled when the current thread yields. However, egos-2000 has a <strong>preemptive</strong> scheduler meaning that the current thread is forced to yield even if it does not directly invoke the yield function. This is made possible by <strong>timer interrupts</strong>, so we start by introducing what is a timer.</p><p><img src="'+t+`" alt="Failed to load picture"></p><p>This screenshot is a timer in MacOS. You can set the timer with a value (e.g., 15 seconds), and then start the timer. After this time period elapsed, the timer will raise an interrupt (e.g., the Radial ringtone). This project helps you understand how to do something similar with a RISC-V CPU and, instead of raising ringtones, the CPU will set the program counter to the code of a special function when the time period elapsed. This special function is called an <strong>interrupt handler</strong> which will further invoke <code>proc_yield</code>, switching the context of the CPU to a different thread in egos-2000.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>We do not distinguish <strong>thread</strong> and <strong>process</strong> for now, so you can simply regard the <code>struct process</code> and <code>proc_yield</code> from egos-2000 as the <code>struct thread</code> and <code>thread_yield</code> from P1. We start to distinguish the two when introducing virtual memory in P4.</p></div><h2 id="timer-interrupt" tabindex="-1">Timer interrupt <a class="header-anchor" href="#timer-interrupt" aria-label="Permalink to &quot;Timer interrupt&quot;">​</a></h2><p>We start by explaining the following demo program which prints <code>Got a timer interrupt.</code> repeatedly every <code>QUANTUM</code> time units (e.g., 10^-7 second).</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QUANTUM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Register the handler. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrw mtvec, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handler));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Set a timer period. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mtimecmp_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mtime_get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QUANTUM);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Enable timer interrupt. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrs mie, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrs mstatus, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* When a timer interrupt is raised, the CPU behaves as if a</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       call to function handler() is added into this while loop. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Got a timer interrupt.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mtimecmp_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mtime_get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QUANTUM);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* When invoking mret, the CPU behaves as if handler()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       is returning to the while loop in function main(). */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="register-the-handler" tabindex="-1">Register the handler <a class="header-anchor" href="#register-the-handler" aria-label="Permalink to &quot;Register the handler&quot;">​</a></h3><p>The first line of the main function registers <code>handler()</code> as the interrupt handler. The syntax might look a bit scary, but its job is actually very simple.</p><p>First, <code>mtvec</code> is a <strong>Control and Status Register</strong> (CSR), meaning that it has special purposes unlike the general-purpose registers. The special purpose of <code>mtvec</code> is to hold the starting address of the interrupt handler. In other words, the CPU would set the program counter to the value held by <code>mtvec</code> when receiving an interrupt. You can learn more about <code>mtvec</code> in chapter 3.1.7 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>.</p><p>Second, <code>csrw</code> is the CPU instruction for writing a CSR and, in this case, the value written to the <code>mtvec</code> CSR is the address of the first instruction in function <code>handler</code>. Say this address is <code>0x80000020</code>, we can directly write <code>asm(&quot;csrw mtvec, %0&quot; ::&quot;r&quot;(0x80000020))</code> as well. By using function pointer <code>handler</code>, the compiler will figure out this address for us. This line of C code would likely be compiled to the following assembly:</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lui     a5,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # a5 is now 0x8000_0000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addi    a5,a5,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # a5 is now 0x8000_0020</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">csrw    mtvec,a5   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # write the value of a5 to mtvec</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The compiler can also choose registers and instructions other than <code>a5</code>, <code>lui</code> and <code>addi</code> as long as the address of <code>handler</code>&#39;s first instruction is written to <code>mtvec</code>.</p><h3 id="set-a-timer-period" tabindex="-1">Set a timer period <a class="header-anchor" href="#set-a-timer-period" aria-label="Permalink to &quot;Set a timer period&quot;">​</a></h3><p>The second line of the main function sets a timer period of <code>QUANTUM</code> just like we set a 15-second period in the screenshot. You can find function <code>mtimecmp_set</code> and <code>mtime_get</code> in <code>earth/cpu_intr.c</code> of egos-2000. They are copy-pasted from the CPU reference manual, and their job is to read or write 8-byte values at special memory addresses.</p><p>Specifically, <code>mtime</code> and <code>mtimecmp</code> represent two special memory addresses. <code>mtime_get</code> reads 8 bytes from <code>mtime</code> representing how many time units have elapsed since the CPU was powered on. Hence, this 8-byte value at <code>mtime</code> is <strong>automatically incremented</strong> by the CPU as time proceeds, and the return value of <code>mtime_get</code> depends on when this function is invoked. When the value at <code>mtime</code> equals the value at <code>mtimecmp</code>, a timer interrupt will be raised, which explains why this line of code sets a timer period of <code>QUANTUM</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>You may regard the timer as a simple device controlled by <code>mtime</code> and <code>mtimecmp</code>. In addition to <code>mtime</code> and <code>mtimecmp</code>, there exist other special memory regions that are used to control various devices connected to the CPU. You will learn about other such regions in P5 in which we will use <strong>memory-mapped I/O</strong> to control an SD card and a VGA graphical display.</p></div><h3 id="enable-timer-interrupt" tabindex="-1">Enable timer interrupt <a class="header-anchor" href="#enable-timer-interrupt" aria-label="Permalink to &quot;Enable timer interrupt&quot;">​</a></h3><p>The main function then sets bit#3 of <code>mstatus</code> and bit#7 of <code>mie</code> to 1 (i.e., <code>0x8</code> is <code>1&lt;&lt;3</code>, <code>0x80</code> is <code>1&lt;&lt;7</code>) with the CSR set bit instruction <code>csrs</code>. According to Figure 7 and Figure 16 from <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>, bit#3 of <code>mstatus</code> is called <code>mstatus.MIE</code> where <code>MIE</code> stands for <strong>Machine Interrupt Enable</strong>, and bit#7 of <code>mie</code> is called <code>mie.MTIE</code> where <code>MTIE</code> stands for <strong>Machine Timer Interrupt Enable</strong>.</p><p><img src="`+e+'" alt="Failed to load picture"><img src="'+l+'" alt="Failed to load picture"></p><p>For the purpose of P2, it is enough to know that setting the <code>mstatus.MIE</code> and <code>mie.MTIE</code> bits will enable timer interrupts on the CPU while setting either of them to 0 would disable timer interrupts. We recommend you to scan through chapter 3.1.6 and 3.1.9 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a> for <code>mstatus</code> and <code>mie</code>, but don&#39;t feel obliged to understand everything. We will explain the other bits of these CSRs in the next few projects.</p><p>After enabling timer interrupts, the main function enters an infinite loop. When receiving a timer interrupt, the CPU would behave as if a function call to <code>handler</code> is inserted into this loop, and the <code>handler</code> function would reset the timer with <code>QUANTUM</code> again. Therefore, we expect to see <code>Got a timer interrupt.</code> on the screen periodically and infinitely.</p><h3 id="usage-of-mepc-and-mret" tabindex="-1">Usage of <code>mepc</code> and <code>mret</code> <a class="header-anchor" href="#usage-of-mepc-and-mret" aria-label="Permalink to &quot;Usage of `mepc` and `mret`&quot;">​</a></h3><p>Right before handling a timer interrupt, the CPU assigns the value of its program counter to a CSR called <code>mepc</code>, so <code>mepc</code> should point to an instruction for <code>while(1);</code> when <code>handler</code> starts to run. Reversely, when <code>handler</code> invokes <code>mret</code>, the CPU assigns the value of <code>mepc</code> back to the program counter, so the CPU will resume the while loop. Moreover, right before the CPU jumps to <code>handler</code>, interrupts are <strong>automatically disabled</strong>. When <code>handler</code> invokes <code>mret</code>, CPU interrupts will be automatically re-enabled. In other words, we typically hope to handle one interrupt without being disrupted by another interrupt.</p><p>Below is a screenshot of chapter 8.2.1 in <a href="assets/fu540-c000-manual-v1p4.pdf">this CPU document</a> which describes the details.</p><p><img src="'+r+`" alt="Failed to load picture"></p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Take your time to read the screenshot above. It is a very important part of how operating systems work. We will revisit this screenshot in P3, especially the descriptions of privilege mode.</p></div><h2 id="process-lifecycle-and-priority" tabindex="-1">Process lifecycle and priority <a class="header-anchor" href="#process-lifecycle-and-priority" aria-label="Permalink to &quot;Process lifecycle and priority&quot;">​</a></h2><p>The goal of this project is to help you understand <strong>preemptive scheduling</strong>, the application of timer interrupt to process scheduling. As mentioned at the beginning, we do not distinguish <em>thread</em> and <em>process</em> for now, so we will use the two terms interchangeably.</p><p>The code for timer interrupt in egos-2000 is in <code>earth/cpu_intr.c</code> which is essentially the same as the timer demo program above but registers <code>trap_entry</code> as the handler function. The <code>trap_entry</code> in <code>grass/kernel.s</code> is the starting point of preemptive scheduling.</p><h3 id="save-and-restore-registers" tabindex="-1">Save and restore registers <a class="header-anchor" href="#save-and-restore-registers" aria-label="Permalink to &quot;Save and restore registers&quot;">​</a></h3><p>At first glance, most of the code in <code>trap_entry</code> looks similar to the <code>SAVE_ALL_REGISTERS</code> and <code>RESTORE_ALL_REGISTERS</code> in P1. Indeed, the high-level goal is the same: save the value of all general-purpose registers on the stack when a thread yields, and restore the value of such registers when switching back to this thread.</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trap_entry:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    csrw mscratch, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    li </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80200000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addi </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SAVE_ALL_REGISTERS    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Save registers for the current thread. */</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kernel_entry     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Pick the next thread. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RESTORE_ALL_REGISTERS </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Restore registers for the next thread. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>There are two differences. First, egos-2000 saves the registers on the operating system&#39;s stack which starts from <code>0x80200000</code>. Specifically, the 128-byte region under <code>0x80200000</code> is used to save the registers, indicated by the <code>li</code> and <code>addi</code> instructions above. Since they modify register <code>sp</code>, the old value of <code>sp</code> is written to a CSR called <code>mscratch</code> and later read back in the <code>SAVE_ALL_REGISTERS</code> part, right before saving this value on the stack.</p><p>The second difference is that <code>mret</code> is used at the end of <code>trap_entry</code> instead of <code>ret</code>. In P1, threads need to explicitly call <code>thread_yield</code> which further calls <code>ctx_switch</code>, so the value of register <code>ra</code> saved on the stack by <code>ctx_switch</code> is an address in <code>thread_yield</code>. With this value of <code>ra</code>, <code>ctx_switch</code> can return to <code>thread_yield</code> simply by calling <code>ret</code>. In P2, threads are preempted by a timer interrupt instead of calling a yield function voluntarily. Therefore, <code>mepc</code> and <code>mret</code> are used to save and restore the program counter.</p><p>The <code>kernel_entry</code> highlighted above is in <code>grass/kernel.c</code>, and it does 3 things:</p><ul><li><p>Copy <code>mepc</code> and the saved registers of the current thread into its <strong>process control block</strong>, a data structure similar to the thread control block in P1.</p></li><li><p>Pick the next thread by calling <code>proc_yield</code>, a function similar to <code>thread_yield</code> in P1.</p></li><li><p>Restore <code>mepc</code> and the saved registers for the next thread from its process control block.</p></li></ul><h3 id="process-control-block" tabindex="-1">Process control block <a class="header-anchor" href="#process-control-block" aria-label="Permalink to &quot;Process control block&quot;">​</a></h3><p>In addition to the <code>mepc</code> and <code>saved_registers</code> highlighted below, the process control block of egos-2000 is defined in <code>grass/process.h</code> which contains a few other fields:</p><ul><li>a process identifier <code>pid</code></li><li>a data structure for system calls which will be explained in P3</li><li>the <code>status</code> of a process which is closely related to the <strong>lifecycle of a process</strong></li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall syscall;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proc_status status;</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mepc, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">saved_registers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The lifecycle of a process is illustrated by the <code>enum proc_status</code> in <code>grass/process.h</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proc_status {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_UNUSED,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_LOADING,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_READY,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_RUNNING,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_RUNNABLE,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_PENDING_SYSCALL</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* We will explain this one in P3. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Specifically, the <code>status</code> in a <code>struct process</code> would experience the following stages:</p><ol><li>When creating a new process, the <code>status</code> is set from <code>PROC_UNUSED</code> to <code>PROC_LOADING</code>. This happens in the <code>proc_alloc</code> function in <code>grass/process.c</code>.</li><li>The <code>elf_load</code> function in <code>library/elf/elf.c</code> loads the code and data for the process from disk into memory, and then the <code>status</code> is set from <code>PROC_LOADING</code> to <code>PROC_READY</code>. We will explain the details of <code>elf_load</code> in P4, and you can ignore it for now.</li><li>After loading the code and data, the <code>proc_yield</code> in <code>grass/kernel.c</code> will schedule this new process and set the <code>status</code> from <code>PROC_READY</code> to <code>PROC_RUNNING</code>.</li><li>Upon a timer interrupt, the control flow enters <code>proc_yield</code> again and, if it picks another process to run next, the <code>status</code> of the current process will be set from <code>PROC_RUNNING</code> to <code>PROC_RUNNABLE</code>. The <code>status</code> then switches back and forth between <code>PROC_RUNNABLE</code> and <code>PROC_RUNNING</code> because of executing <code>proc_yield</code> upon every timer interrupt.</li><li>When a process terminates, the <code>proc_free</code> function in <code>grass/process.c</code> will be called, and <code>proc_free</code> sets the <code>status</code> back to <code>PROC_UNUSED</code>.</li></ol><p>These bullets help you understand the lifecycle of a process. Your first task in this project is to collect some statistics about the lifecycle of every process.</p><h3 id="collect-lifecycle-statistics" tabindex="-1">Collect lifecycle statistics <a class="header-anchor" href="#collect-lifecycle-statistics" aria-label="Permalink to &quot;Collect lifecycle statistics&quot;">​</a></h3><p>Add new fields in <code>struct process</code> and update these fields at the right places, so you can collect the following statistics for every process.</p><ul><li><strong>turnaround time</strong>: the time between process creation and termination</li><li><strong>response time</strong>: the time between process creation and the first time scheduled</li><li><strong>CPU time</strong>: the accumulated time that the process is actually running on the CPU</li><li><strong>number of timer interrupts encountered</strong>: how many times the CPU control flow transfers from the process code to <code>trap_entry</code> due to a timer interrupt</li></ul><p>Process creation, termination and first schedule correspond to bullet 1, 5 and 3 in the above explanation for process lifecycles. To measure time, call the <code>mtime_get</code> function twice and the difference of the two return values is the time elapsed in 10^-7 second (on QEMU). Note that <code>mtime_get</code> is also the function previously used by the timer demo program.</p><p>Print the statistics when a process terminates. Note that the <code>ms</code> below is millisecond (10^-7 * 10000 second), and you can simply assume that the numbers printed will not overflow the <code>int</code> type (i.e., you can use <code>%d</code> within <code>printf</code> or <code>INFO</code>).</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>➜ /home/yunhao echo Hello, World!</span></span>
<span class="line"><span>Hello, World!</span></span>
<span class="line"><span>[INFO] process 6 terminated after 0 timer interrupts, turnaround time: 174ms, response time: 170ms, CPU time: 1ms</span></span>
<span class="line"><span>➜ /home/yunhao ls</span></span>
<span class="line"><span>./     ../     README</span></span>
<span class="line"><span>[INFO] process 7 terminated after 0 timer interrupts, turnaround time: 233ms, response time: 215ms, CPU time: 1ms</span></span>
<span class="line"><span>➜ /home/yunhao loop 500 silent</span></span>
<span class="line"><span>[INFO] process 8 terminated after 12 timer interrupts, turnaround time: 1515ms, response time: 233ms, CPU time: 1280ms</span></span>
<span class="line"><span>➜ /home/yunhao loop 500</span></span>
<span class="line"><span>loop #0</span></span>
<span class="line"><span>loop #1</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>loop #499</span></span>
<span class="line"><span>[INFO] process 9 terminated after 0 timer interrupts, turnaround time: 2269ms, response time: 240ms, CPU time: 1670ms</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Try to explain the different statistics between <code>loop 500</code> and <code>loop 500 silent</code>. For example, why <code>loop 500</code> encounters no timer interrupt and <code>loop 500 silent</code> encounters 12, although the CPU time is close? Note that QEMU can run faster or slower on different machines, so you can see time statistics different from above. The above statistics are printed by running egos-2000 on MacBook Air (M2, 2022) and <a href="https://github.com/xpack-dev-tools/qemu-riscv-xpack/releases/tag/v7.2.5-1" target="_blank" rel="noreferrer">QEMU v7.2.5 released by xPack</a>.</p></div><h3 id="multilevel-feedback-queue" tabindex="-1">Multilevel feedback queue <a class="header-anchor" href="#multilevel-feedback-queue" aria-label="Permalink to &quot;Multilevel feedback queue&quot;">​</a></h3><p>Your final task in this project is to implement the notion of process priority in the scheduler, which is also known as the MultiLevel Feedback Queue (MLFQ) scheduler. Specifically, you need to implement a variant of MLFQ with simple rules:</p><ol><li>There are 5 levels, level #0 to #4. All processes start at level #0 when created.</li><li>Processes at level #i can run on the CPU for <code>(i+1)*100</code> milliseconds. For example, if a process at level #0 has run on the CPU for more than 100ms, it will move to level #1. After running for another 200ms, it will move to level #2. Since there are 5 levels, all processes at level #4 will remain at this level without moving further.</li><li>The scheduler in <code>proc_yield</code> should always choose a runnable process with the <strong>lowest level number</strong> (i.e., highest priority) as the next process.</li><li>Every 10 seconds or so, the scheduler in <code>proc_yield</code> should move all processes to level #0. In addition, if there is keyboard input for the shell, move <code>GPID_SHELL</code> to level #0.</li></ol><p>Some definitions for MLFQ have been provided in egos-2000:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_NLEVELS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_RESET_PERIOD</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     10000000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* 10 seconds */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_LEVEL_RUNTIME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* e.g., 100ms for level 0 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mlfq_update_level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ulonglong </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">runtime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mlfq_reset_level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">earth-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tty_input_empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ulonglong MLFQ_last_reset_time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>You can implement the MLFQ scheduler by implementing the two functions above, and call these functions in <code>proc_yield</code>. Specifically, add new fields in <code>struct process</code> recording the level and the remaining runtime on that level. Suppose a process <code>p</code> has run for another <code>runtime</code> unit of time: <code>mlfq_update_level</code> updates the new fields according to the rule #2. When providing the <code>runtime</code> argument, reuse your time measurement for CPU time.</p><p>The <code>mlfq_reset_level</code> function moves all processes to level #0 according to the rule #4 above. Use <code>earth-&gt;tty_input_empty()</code> to see whether the shell gets new keyboard input, and use the <code>MLFQ_last_reset_time</code> variable to track whether an <code>MLFQ_RESET_PERIOD</code> has elapsed since the last time moving all processes to level #0.</p><p>Lastly, you need to modify the <code>for</code> loop in <code>proc_yield()</code> according to the rule #3 above. Make sure to call <code>proc_try_syscall()</code> for processes with status <code>PROC_PENDING_SYSCALL</code> just like the current code. After you finish, test your code with the shell commands below.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; make qemu</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>[CRITICAL] Welcome to the egos-2000 shell!</span></span>
<span class="line"><span>➜ /home/yunhao loop &amp;</span></span>
<span class="line"><span>[INFO] process 6 running in the background</span></span>
<span class="line"><span>➜ /home/yunhao loop &amp;</span></span>
<span class="line"><span>[INFO] process 7 running in the background</span></span>
<span class="line"><span>➜ /home/yunhao ls</span></span>
<span class="line"><span>./     ../     README</span></span>
<span class="line"><span>➜ /home/yunhao killall</span></span>
<span class="line"><span>➜ /home/yunhao ls</span></span>
<span class="line"><span>./     ../     README</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>You can certainly run the commands above with the current scheduler and with your MLFQ scheduler. With the current scheduler, the first <code>ls</code> would take a long time because this <code>ls</code> is interleaved with the background loops. After the <code>killall</code>, <code>ls</code> would become fast again. With your MLFQ scheduler, the two background loops should quickly move to lower priority, so the first <code>ls</code> should be fast just like the second <code>ls</code>. Confirm such an improvement made by MLFQ using the turnaround time printed when <code>ls</code> terminates.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have started to learn about control and status registers which is the key CPU support for operating systems. You will see more CSRs in the next projects. You have also finished reading <code>earth/cpu_intr.c</code>, <code>grass/kernel.s</code> and half of <code>grass/kernel.c</code> in egos-2000.</p>`,66),c=[p];function h(d,k,u,m,g,b){return a(),i("div",null,c)}const v=s(o,[["render",h]]);export{f as __pageData,v as default};
