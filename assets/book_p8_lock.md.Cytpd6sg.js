import{_ as e,c as s,o as i,a2 as a}from"./chunks/framework.CeQAp18V.js";const g=JSON.parse('{"title":"Multicore & Locks","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"book/p8_lock.md","filePath":"book/p8_lock.md"}'),n={name:"book/p8_lock.md"},t=a(`<h1 id="multicore-locks" tabindex="-1">Multicore &amp; Locks <a class="header-anchor" href="#multicore-locks" aria-label="Permalink to &quot;Multicore &amp; Locks&quot;">​</a></h1><p>In previous projects, we have been running the operating system and user applications on one CPU core. However, multicore CPUs have been widely used: a laptop typically has a CPU with 4 to 16 cores while the CPU on a server machine in a data center could have 64 or more cores. Multicore leads to higher software performance because multiple processes can then run on different cores at the same time, and therefore multiple software tasks can make progress in parallel.</p><p>Handling multiple cores involves an important concept called <strong>mutual exclusion</strong>. In general, mutual exclusion prevents multiple CPU cores from using a shared resource at the same time. For example, when the kernel code is running on a core and updating a data structure (e.g., the PCB), it may need exclusive access to such data structures while preventing other cores from updating them simultaneously. Otherwise, these kernel data structures could be corrupted by simultaneous updates. We thus start by introducing mutual exclusion.</p><h2 id="mutual-exclusion" tabindex="-1">Mutual exclusion <a class="header-anchor" href="#mutual-exclusion" aria-label="Permalink to &quot;Mutual exclusion&quot;">​</a></h2><p>When you run egos-2000 on QEMU, you may have noticed that the first line printed is one of the four possibilities listed below. In other words, a core is randomly selected from #1 .. #4 to run egos-2000 when you run it on QEMU.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[CRITICAL] --- Booting on QEMU with core #1 ---</span></span>
<span class="line"><span>[CRITICAL] --- Booting on QEMU with core #2 ---</span></span>
<span class="line"><span>[CRITICAL] --- Booting on QEMU with core #3 ---</span></span>
<span class="line"><span>[CRITICAL] --- Booting on QEMU with core #4 ---</span></span></code></pre></div><p>This is a typical example of mutual exclusion. Specifically, the public egos-2000 code only supports a single core, so the booting code (aka. boot loader) will prevent the other 3 cores from running egos-2000 after egos-2000 has already started to run on a core. Such mutual exclusion requires a new class of CPU instructions called <strong>atomic memory operations</strong> which is an extension to the basic RISC-V instruction set architecture.</p><h3 id="atomic-memory-operation" tabindex="-1">Atomic memory operation <a class="header-anchor" href="#atomic-memory-operation" aria-label="Permalink to &quot;Atomic memory operation&quot;">​</a></h3><p>The assembly code below is from <code>earth/boot.s</code> which shows the first instructions that all the CPU cores will execute when running egos-2000.</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">boot_loader:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    la t0, boot_lock</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    li t1, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    amoswap.w.aq t1, t1, (t0)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bnez t1, boot_loader</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    li </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80200000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> boot</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.bss</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    boot_lock:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       .</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">word</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    booted_core_cnt:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">word</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Line 9 means that there is a 4-byte variable named <code>boot_lock</code> that is initialized as 0 before all the cores start to execute the first instruction (i.e., the <code>la</code> instruction in <code>boot_loader</code>). The first two instructions load the address of <code>boot_lock</code> to register <code>t0</code> and load value <code>1</code> to register <code>t1</code>. The magic happens at the <code>amoswap.w.aq</code> instruction where <code>amo</code> stands for atomic memory operation. It swaps the value of <code>t1</code> with the 4 bytes at memory address <code>t0</code> atomically. Atomicity here means that only one of the CPU cores could swap back the initial <code>0</code> value of <code>boot_lock</code>, after which all the other cores will swap back value <code>1</code>.</p><p>Therefore, the first core that completes <code>amoswap.w.aq</code> will proceed while the other cores will be trapped into an infinite loop because of the <code>bnez</code> instruction as long as <code>boot_lock</code> continues to hold value <code>1</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>The magic of <code>amoswap.w.aq</code> is enforced by the CPU hardware design. The CPU hardware decides which core should be the first when multiple cores try to execute this instruction at the same time. This is closely related to the <a href="https://en.wikipedia.org/wiki/Memory_coherence" target="_blank" rel="noreferrer">memory coherence</a> problem in computer architecture.</p></div><p>We say that the code above <strong>acquires</strong> the boot lock and one can <strong>release</strong> this lock by writing value <code>0</code> to the address of <code>boot_lock</code>. After releasing the boot lock, another core would be able to acquire it and proceed with the code logic after the <code>bnez</code> instruction.</p><p>In general, a <strong>lock</strong> is simply a 4-byte variable in the memory holding either <code>0</code> or <code>1</code>. Given a lock variable <code>x</code> in C, we have provided two macros for you in <code>library/egos.h</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__sync_lock_release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> acquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__sync_lock_test_and_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* The __sync_lock_* functions are defined within the C compiler. */</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>While you still need to write some assembly code in this project, you can use these macros whenever you need to acquire or release a lock in your C code. Let&#39;s release the boot lock now and see what will happen.</p><h3 id="release-the-boot-lock" tabindex="-1">Release the boot lock <a class="header-anchor" href="#release-the-boot-lock" aria-label="Permalink to &quot;Release the boot lock&quot;">​</a></h3><p>After acquiring <code>boot_lock</code>, the first booted core sets the stack pointer as <code>0x80200000</code> and calls the <code>boot</code> function in <code>erath/boot.c</code>. Since the <code>booted_core_cnt</code> variable is initially 0, this core will enter the if branch in <code>boot()</code> and calls 4 initialization functions: <code>tty_init</code>, <code>disk_init</code>, <code>mmu_init</code>, and <code>intr_init</code>. They initialize the TTY and disk devices, and the CSRs relating to virtual memory and interrupts. In the end, <code>boot()</code> calls the <code>grass_entry</code> function defined in <code>grass/init.c</code>.</p><p>The <code>grass_entry</code> function loads the binary executable for <code>apps/system/sys_proc.c</code> into memory as the first process, and start to run this process after the <code>mret</code> instruction. Note that after this <code>mret</code>, the first process will set the stack pointer to <code>0x80400000</code> as shown in <code>apps/app.s</code>. This means that the first booted core has <strong>finished using the kernel stack</strong>, so we can safely release the boot lock and allow the next core to call <code>boot()</code>.</p><p>We thus ask you to release the boot lock at the start of <code>apps/system/sys_proc.c</code>. Because <code>grass_entry()</code> has passed the address of <code>boot_lock</code> to this process as an argument for its <code>main</code> function, you can access <code>boot_lock</code> through the <code>struct multicore*</code> argument. Here is one possible printing after releasing the boot lock.</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[CRITICAL] --- Booting on QEMU with core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#1 ---</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SUCCESS] Enter kernel process GPID_PROCESS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SUCCESS] --- Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#4[INFO] Load kern el process #2: sys_tserminal</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tarts</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ---</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Load 0xde8 bytes to 0x80200000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Load 0x11c bytes to 0x80208000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SUCCESS] Enter kernel process GPID_TERMINAL</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Essentially, the first process prints out <code>Enter kernel process GPID_PROCESS</code> normally, but the printing of <code>[INFO] Load kernel process #2: sys_terminal</code> is mixed with the printing of <code>[SUCCESS] --- Core #4 starts running ---</code> defined in <code>earth/boot.c</code>. This is indeed the result of core #1 running the first process while core #4 running <code>boot()</code> in parallel.</p><h3 id="complete-the-boot-loader" tabindex="-1">Complete the boot loader <a class="header-anchor" href="#complete-the-boot-loader" aria-label="Permalink to &quot;Complete the boot loader&quot;">​</a></h3><p>Start with a fresh copy of egos-2000 and incorporate your code for virtual memory in P4.</p><p>Your first task is to complete the code in <code>apps/system/sys_proc.c</code> and <code>earth/boot.c</code>, so all 4 cores can finish booting. Specifically, the 3 cores booting after the first one should set up their CSRs for interrupts and virtual memory, but they do not initialize the TTY or disk devices again. In particular, multicore requires page table translation, so simply do a <code>FATAL</code> in your code if <code>SOFT_TLB</code> has been chosen as the translation mechanism.</p><p>The goal is to see <code>[SUCCESS] --- Core #? starts running ---</code> for all the 3 cores, so we know that all the 4 cores have booted. However, you will likely meet exceptions and <code>FATAL</code> in <code>excp_entry()</code> in the kernel since we have not yet protected the kernel with locks.</p><h2 id="kernel-lock" tabindex="-1">Kernel lock <a class="header-anchor" href="#kernel-lock" aria-label="Permalink to &quot;Kernel lock&quot;">​</a></h2><p>As we have mentioned, if multiple CPU cores use the kernel stack or update the kernel data structures at the same time, these memory regions could be corrupted. Therefore, we have defined <code>kernel_lock</code> in <code>grass/kernel.s</code> which should ensure that, at any time, only one core can access the kernel stack or data structures. Your next task is to acquire and release this kernel lock, protecting the kernel.</p><h3 id="protect-the-kernel" tabindex="-1">Protect the kernel <a class="header-anchor" href="#protect-the-kernel" aria-label="Permalink to &quot;Protect the kernel&quot;">​</a></h3><p>Recall the <code>trap_entry</code> defined in <code>grass/kernel.s</code> which is first introduced in P2. It is the entry point of all the interrupts or exceptions that trap a CPU core into the kernel. In other words, if multiple cores get trapped at the same time, they will all execute the instructions in <code>trap_entry</code> and thus use the kernel stack at <code>0x80200000</code>.</p><p>Intuitively, you will need to acquire the kernel lock before switching to the kernel stack and release the kernel lock right before the <code>mret</code> in <code>trap_entry</code>. There is one key difference from how this is done in <code>earth/boot.s</code>. Recall that <code>trap_entry</code> saves all the registers on the kernel stack before calling <code>kernel_entry</code>, and restores all the registers before <code>mret</code>. This requires that your code for acquiring or releasing the lock does not modify the value of any registers. This can be achieved by using the so-called scratch CSRs such as <code>mscratch</code> and <code>ssratch</code>. For example, to keep the value of the <code>sp</code> register, <code>trap_entry</code> has already been using the <code>mscratch</code> CSR to record the old value of <code>sp</code>.</p><p>After your modifications to <code>grass/kernel.s</code>, there is only one more thing you need to do in <code>grass/kernel.c</code>. Given multiple CPU cores, it is possible that a core has to be idle, i.e., the scheduler cannot find a RUNNABLE process to run on this core. As a result, we need to ask an idle core to do nothing before it receives the next timer interrupt. And you will implement this before the <code>FATAL</code> in <code>proc_yield</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>We use a single lock to protect the whole kernel because it is simple. In many operating systems, there are separate kernel stacks dedicated to different CPU cores so that kernel stacks don&#39;t need to be protected by locks. There are different locks protecting different kernel data structures.</p></div><h3 id="run-processes-in-parallel" tabindex="-1">Run processes in parallel <a class="header-anchor" href="#run-processes-in-parallel" aria-label="Permalink to &quot;Run processes in parallel&quot;">​</a></h3><p>Now, let us run multiple processes on different CPU cores and see whether our kernel can indeed handle multicore. Specifically, you will implement the <code>proc_coresinfo</code> function at the end of <code>grass/kernel.c</code> and add this function into <code>struct grass</code>, so the shell can call this function for the <code>coresinfo</code> built-in command (see <code>apps/system/sys_shell.c</code>). After you finish, run multiple processes in the background and try <code>coresinfo</code> in the shell.</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[CRITICAL] Welcome to the egos-2000 shell</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 9</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> coresinfo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] ==============Core ID / Process ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=============</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#1 is running pid=6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#2 is running pid=4 (GPID_SHELL)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#3 is running pid=7</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#4 is running pid=9</span></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> coresinfo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] ==============Core ID / Process ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=============</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#1 is running pid=8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#2 is running pid=9</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#3 is running pid=4 (GPID_SHELL)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] Core </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#4 is running pid=7</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>In this demo, we started 4 processes in the background and, if we run <code>coresinfo</code> multiple times, different cores would be running different processes. For the first <code>coresinfo</code> above, processes #6, #7 and #9 were running while #8 was not running (i.e., RUNNABLE). You can also try the <code>killall</code> built-in command after which all the <code>loop</code> processes will terminate. Here is a <a href="https://youtu.be/sUIznQKcGu8" target="_blank" rel="noreferrer">video with more details of this demo</a>.</p><h3 id="find-concurrency-bugs" tabindex="-1">Find concurrency bugs <a class="header-anchor" href="#find-concurrency-bugs" aria-label="Permalink to &quot;Find concurrency bugs&quot;">​</a></h3><p>Being able to run a demo does not mean that your code is free of bugs. <strong>Concurrency bugs</strong> refer to bugs that could happen when multiple programs are running concurrently. For this project, a concurrency bug could be programs running on different cores modifying certain kernel data structures at the same time. While we have protected the kernel with the kernel lock, such concurrency bugs still exist. See whether you can find and fix them.</p><p>In general, concurrency bugs are difficult to find and debug because they typically happen neither deterministically nor often. Given that egos-2000 has a small code base and it uses simple data structures, a good way to remove concurrency bugs is to reason about the use of all the data structures very carefully.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>If you wish to learn more about parallel programming in operating systems, this book is a fun read: <a href="https://arxiv.org/abs/1701.00854" target="_blank" rel="noreferrer">Is Parallel Programming Hard, And, If So, What Can You Do About It? </a> Also, if you run your code on the Arty board, you need to add a few <code>nop</code> after each <code>amoswap</code> instruction. The reason is that the CPU design for the Arty board has a flaw and it cannot complete the <code>amoswap</code> instruction in one CPU cycle. By adding a few <code>nop</code>, the CPU core waits for <code>amoswap</code> to complete before proceeding into a <a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noreferrer">critical section</a>.</p></div><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have gained hands-on experience with atomic memory operations, an extension to the RISC-V instruction set for multicore. You have seen how multiple cores execute instructions (e.g., do printing) in parallel, and how to protect the egos-2000 kernel with the kernel lock. Lastly, you have seen that concurrency bugs are sometimes not obvious because they may not happen often or deterministically.</p>`,44),o=[t];function l(r,h,c,p,d,k){return i(),s("div",null,o)}const m=e(n,[["render",l]]);export{g as __pageData,m as default};
