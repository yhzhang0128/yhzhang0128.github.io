<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Preemptive Scheduler | The EGOS book</title>
    <meta name="description" content="Envision a future where every student can read all the code of a teaching operating system. ">
    <meta name="generator" content="VitePress v1.3.4">
    <link rel="preload stylesheet" href="/assets/style.BIc4tlAO.css" as="style">
    
    <script type="module" src="/assets/app.D9uQzcqb.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.CiT-GGh0.js">
    <link rel="modulepreload" href="/assets/chunks/framework.CeQAp18V.js">
    <link rel="modulepreload" href="/assets/chunks/mstatus.AnuZ0eMl.js">
    <link rel="modulepreload" href="/assets/book_p2_mlfq.md.CM-CgUM1.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8b57b2d><!--[--><!--]--><!--[--><span tabindex="-1" data-v-c8291ffa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-c8291ffa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-d8b57b2d data-v-7ad780c2><div class="VPNavBar has-sidebar top" data-v-7ad780c2 data-v-9fd4d1dd><div class="wrapper" data-v-9fd4d1dd><div class="container" data-v-9fd4d1dd><div class="title" data-v-9fd4d1dd><div class="VPNavBarTitle has-sidebar" data-v-9fd4d1dd data-v-0ad69264><a class="title" href="/" data-v-0ad69264><!--[--><!--]--><!----><span data-v-0ad69264>The EGOS book</span><!--[--><!--]--></a></div></div><div class="content" data-v-9fd4d1dd><div class="content-body" data-v-9fd4d1dd><!--[--><!--]--><div class="VPNavBarSearch search" data-v-9fd4d1dd><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-9fd4d1dd data-v-afb2845e><span id="main-nav-aria-label" class="visually-hidden" data-v-afb2845e> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-afb2845e data-v-08fbf4b6><!--[--><span data-v-08fbf4b6>Vision</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/book/overview.html" tabindex="0" data-v-afb2845e data-v-08fbf4b6><!--[--><span data-v-08fbf4b6>Overview</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-9fd4d1dd data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-9fd4d1dd data-v-ef6192dc data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/yhzhang0128/egos-2000" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-9fd4d1dd data-v-f953d92f data-v-af5898d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-af5898d3><span class="vpi-more-horizontal icon" data-v-af5898d3></span></button><div class="menu" data-v-af5898d3><div class="VPMenu" data-v-af5898d3 data-v-20ed86d6><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-e71e869c><!--[--><a class="VPSocialLink no-icon" href="https://github.com/yhzhang0128/egos-2000" aria-label="github" target="_blank" rel="noopener" data-v-e71e869c data-v-358b6670><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-9fd4d1dd data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-9fd4d1dd><div class="divider-line" data-v-9fd4d1dd></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8b57b2d data-v-2488c25a><div class="container" data-v-2488c25a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-2488c25a><span class="vpi-align-left menu-icon" data-v-2488c25a></span><span class="menu-text" data-v-2488c25a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-2488c25a data-v-883964e0><button data-v-883964e0>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-d8b57b2d data-v-42c4c606><div class="curtain" data-v-42c4c606></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-42c4c606><span class="visually-hidden" id="sidebar-aria-label" data-v-42c4c606> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-51288d80><section class="VPSidebarItem level-0 has-active" data-v-51288d80 data-v-edd2eed8><!----><div class="items" data-v-edd2eed8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/overview.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>Overview</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p0_hello.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P0: Hello, World!</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p1_ct.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P1: Cooperative Threads</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p2_mlfq.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P2: Preemptive Scheduler</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p3_syscall.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P3: System Call & Protection</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p4_vm.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P4: Virtual Memory</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p5_sd.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P5: Serial Device Driver</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p6_file.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P6: File System</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p7_net.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P7: Ethernet & TCP/IP</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/p8_lock.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>P8: Multicore & Locks</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-edd2eed8 data-v-edd2eed8><div class="item" data-v-edd2eed8><div class="indicator" data-v-edd2eed8></div><a class="VPLink link link" href="/book/outcome.html" data-v-edd2eed8><!--[--><p class="text" data-v-edd2eed8>The Learning Outcomes</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8b57b2d data-v-9a6c75ad><div class="VPDoc has-sidebar has-aside" data-v-9a6c75ad data-v-e6f2a212><!--[--><!--]--><div class="container" data-v-e6f2a212><div class="aside" data-v-e6f2a212><div class="aside-curtain" data-v-e6f2a212></div><div class="aside-container" data-v-e6f2a212><div class="aside-content" data-v-e6f2a212><div class="VPDocAside" data-v-e6f2a212 data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-f610f197><div class="content" data-v-f610f197><div class="outline-marker" data-v-f610f197></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f610f197>On this page</div><ul class="VPDocOutlineItem root" data-v-f610f197 data-v-53c99d69><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e6f2a212><div class="content-container" data-v-e6f2a212><!--[--><!--]--><main class="main" data-v-e6f2a212><div style="position:relative;" class="vp-doc _book_p2_mlfq" data-v-e6f2a212><div><h1 id="preemptive-scheduler" tabindex="-1">Preemptive Scheduler <a class="header-anchor" href="#preemptive-scheduler" aria-label="Permalink to &quot;Preemptive Scheduler&quot;">​</a></h1><p>This project helps you understand the <strong>scheduler</strong> of egos-2000. Most of the egos-2000 scheduler logic is in the <code>proc_yield</code> function from <code>grass/kernel.c</code> which, similar to the <code>thread_yield</code> function in P1, chooses the next thread to be scheduled when the current thread yields. However, egos-2000 has a <strong>preemptive</strong> scheduler meaning that the current thread is forced to yield even if it does not directly invoke the yield function. This is made possible by <strong>timer interrupts</strong>, so we start by introducing what is timer.</p><p><img src="/assets/p2_timer.Dtw002EP.png" alt="Failed to load picture"></p><p>The screenshot above is a timer in MacOS. You can set the timer with an initial value (e.g., 15 seconds) and then start the timer. After this time period elapsed, the timer will raise an interrupt (e.g., the radial ringtone). This project helps you understand how to do something similar with a RISC-V CPU and, instead of raising ringtones, the CPU will set the program counter to the code of a special function when the period elapsed. This special function is called an <strong>interrupt handler</strong> which will further invoke <code>proc_yield</code>, switching the context of the CPU to a different thread in egos-2000.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>We do not distinguish <strong>thread</strong> and <strong>process</strong> for now, so you can simply regard the <code>struct process</code> and <code>proc_yield</code> from egos-2000 as the <code>struct thread</code> and <code>thread_yield</code> from P1. We start to distinguish the two when introducing virtual memory in P4.</p></div><h2 id="timer-interrupt" tabindex="-1">Timer interrupt <a class="header-anchor" href="#timer-interrupt" aria-label="Permalink to &quot;Timer interrupt&quot;">​</a></h2><p>We start by explaining the following demo program which prints <code>Got a timer interrupt.</code> repeatedly every <code>QUANTUM</code> time units (e.g., microseconds).</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QUANTUM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Register the handler. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrw mtvec, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handler));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Set a timer period. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mtimecmp_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mtime_get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QUANTUM);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Enable timer interrupt. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrs mie, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">csrs mstatus, %0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ::</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* When receiving a timer interrupt, the CPU behaves as if a</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       call to handler() is inserted into the while loop below. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Got a timer interrupt.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    mtimecmp_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mtime_get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> QUANTUM);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* When invoking mret, the CPU behaves as if handler()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       is returning to the while loop in main() above. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    asm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="register-the-handler" tabindex="-1">Register the handler <a class="header-anchor" href="#register-the-handler" aria-label="Permalink to &quot;Register the handler&quot;">​</a></h3><p>The first line of the main function registers function <code>handler</code> as the interrupt handler. The C language syntax might look a bit scary, but its job is actually very simple.</p><p>First, <code>mtvec</code> is a <strong>Control and Status Register</strong> (CSR), meaning that it has special purposes unlike the general-purpose registers. The special purpose of <code>mtvec</code> is to hold the starting address of the interrupt handler. In other words, the CPU would set the program counter to the value held by <code>mtvec</code> when receiving an interrupt. You can learn more about <code>mtvec</code> in chapter 3.1.7 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>.</p><p>Second, <code>csrw</code> is the CPU instruction for writing a CSR and, in this case, the value written to the <code>mtvec</code> CSR is the address of the first instruction in function <code>handler</code>. Say this address is <code>0x80000020</code>, we can directly write <code>asm(&quot;csrw mtvec, %0&quot; ::&quot;r&quot;(0x80000020))</code> as well. By using function pointer <code>handler</code>, the compiler will figure out this address for us. And this line of C code would likely be compiled to the following assembly:</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lui     a5,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # a5 is now 0x8000_0000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addi    a5,a5,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # a5 is now 0x8000_0020</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">csrw    mtvec,a5   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # write the value of a5 to mtvec</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The compiler can also choose registers and instructions other than <code>a5</code>, <code>lui</code> and <code>addi</code> as long as the address of <code>handler</code>&#39;s first instruction is written to <code>mtvec</code>.</p><h3 id="set-a-timer-period" tabindex="-1">Set a timer period <a class="header-anchor" href="#set-a-timer-period" aria-label="Permalink to &quot;Set a timer period&quot;">​</a></h3><p>The second line of the main function sets a timer period of <code>QUANTUM</code> just like we set a 15-second period in the screenshot. You can find function <code>mtimecmp_set</code> and <code>mtime_get</code> in <code>earth/cpu_intr.c</code> of egos-2000. They are copy-pasted from the CPU reference manual and their job is to read or write 8-byte values at special memory addresses.</p><p>Specifically, <code>mtime</code> and <code>mtimecmp</code> represent two special memory addresses. <code>mtime_get</code> reads 8 bytes from <code>mtime</code> representing how many time units have elapsed since the CPU was powered on. Hence, this 8-byte value at <code>mtime</code> is <strong>automatically incremented</strong> by the CPU as time proceeds, and the return value of <code>mtime_get</code> depends on when this function is invoked. When the value at <code>mtime</code> equals the value at <code>mtimecmp</code>, a timer interrupt will be raised, which explains why this line of code sets a timer period of <code>QUANTUM</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>You may regard the timer as a simple device controlled by <code>mtime</code> and <code>mtimecmp</code>. In addition to <code>mtime</code> and <code>mtimecmp</code>, there exist other special memory regions that are used to control various devices connected to the CPU. You will learn about another such region in P5 in which we will use <strong>memory-mapped I/O</strong> to control an SD card.</p></div><h3 id="enable-timer-interrupt" tabindex="-1">Enable timer interrupt <a class="header-anchor" href="#enable-timer-interrupt" aria-label="Permalink to &quot;Enable timer interrupt&quot;">​</a></h3><p>The main function then sets bit#3 of <code>mstatus</code> and bit#7 of <code>mie</code> to 1 (i.e., <code>0x8</code> is <code>1&lt;&lt;3</code>, <code>0x80</code> is <code>1&lt;&lt;7</code>) with the CSR set bit instruction <code>csrs</code>. According to Figure 7 and Figure 16 from <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>, bit#3 of <code>mstatus</code> is called <code>mstatus.MIE</code> where <code>MIE</code> stands for <strong>Machine Interrupt Enable</strong>, and bit#7 of <code>mie</code> is called <code>mie.MTIE</code> where <code>MTIE</code> stands for <strong>Machine Timer Interrupt Enable</strong>.</p><p><img src="/assets/mstatus.C4GpBXdk.png" alt="Failed to load picture"><img src="/assets/mie.CfvvRWxH.png" alt="Failed to load picture"></p><p>For the purpose of P2, it is enough to know that setting the <code>mstatus.MIE</code> and <code>mie.MTIE</code> bits will enable timer interrupts on the CPU while setting either of them to 0 would disable timer interrupts. We recommend you to scan through chapter 3.1.6 and 3.1.9 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a> for <code>mstatus</code> and <code>mie</code>, but don&#39;t feel obliged to understand everything. We will explain the other bits of these CSRs in the next few projects.</p><p>After enabling timer interrupts, the main function enters an infinite loop. When receiving a timer interrupt, the CPU would behave as if a function call to <code>handler</code> is inserted into this loop, and the <code>handler</code> function would reset the timer with <code>QUANTUM</code> again. Therefore, we expect to see <code>Got a timer interrupt.</code> on the screen periodically and infinitely.</p><h3 id="usage-of-mepc-and-mret" tabindex="-1">Usage of <code>mepc</code> and <code>mret</code> <a class="header-anchor" href="#usage-of-mepc-and-mret" aria-label="Permalink to &quot;Usage of `mepc` and `mret`&quot;">​</a></h3><p>Right before handling a timer interrupt, the CPU assigns the value of its program counter to a CSR called <code>mepc</code>, so <code>mepc</code> should point to an instruction for <code>while(1);</code> when <code>handler</code> starts to run. Reversely, when <code>handler</code> invokes <code>mret</code>, the CPU assigns the value of <code>mepc</code> back to the program counter, so the CPU will resume the while loop. Moreover, right before the CPU jumps to <code>handler</code>, interrupts are <strong>automatically disabled</strong>. When <code>handler</code> invokes <code>mret</code>, CPU interrupts will be automatically re-enabled. In other words, we typically hope to handle one interrupt without being disrupted by another interrupt.</p><p>Below is a screenshot of chapter 8.2.1 in <a href="assets/fu540-c000-manual-v1p4.pdf">this CPU document</a> which describes the details.</p><p><img src="/assets/interrupt.Bl3qOwz5.png" alt="Failed to load picture"></p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Take your time to read the screenshot above. It is a very important part of how operating systems work. We will revisit this screenshot in P3, especially the bullets about privilege mode.</p></div><h2 id="process-lifecycle-and-priority" tabindex="-1">Process lifecycle and priority <a class="header-anchor" href="#process-lifecycle-and-priority" aria-label="Permalink to &quot;Process lifecycle and priority&quot;">​</a></h2><p>The goal of this project is to help you understand <strong>preemptive scheduling</strong>, the application of timer interrupt to process scheduling. As mentioned at the beginning, we do not distinguish <em>thread</em> and <em>process</em> for now and we will use the two terms interchangeably.</p><p>The code for timer interrupt in egos-2000 is in <code>earth/cpu_intr.c</code> which is essentially the same as the timer demo program above but registers <code>trap_entry</code> as the handler function. The <code>trap_entry</code> defined in <code>grass/kernel.s</code> is the starting point of process scheduling.</p><h3 id="save-and-restore-registers" tabindex="-1">Save and restore registers <a class="header-anchor" href="#save-and-restore-registers" aria-label="Permalink to &quot;Save and restore registers&quot;">​</a></h3><p>At first glance, most of the code in <code>trap_entry</code> looks similar to the <code>SAVE_ALL_REGISTERS</code> and <code>RESTORE_ALL_REGISTERS</code> in P1. Indeed, the high-level goal is the same: save the value of all general-purpose registers on the stack when a thread yields, and restore the value of such registers when switching back to this thread.</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trap_entry:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    csrw mscratch, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    li </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0x80200000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addi </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SAVE_ALL_REGISTERS    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Save registers for the current thread. */</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kernel_entry     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Pick the next thread. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RESTORE_ALL_REGISTERS </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Restore registers for the next thread. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>There are two differences. First, egos-2000 saves the registers on the operating system&#39;s stack which starts from <code>0x80200000</code>. Specifically, the 128-byte region under <code>0x80200000</code> is used to save the registers, indicated by the <code>li</code> and <code>addi</code> instructions above. Since they modify register <code>sp</code>, the old value of <code>sp</code> is written to a CSR called <code>mscratch</code> and later read back in the <code>SAVE_ALL_REGISTERS</code> part, right before saving this value on the stack.</p><p>The second difference is that <code>mret</code> is used at the end of <code>trap_entry</code> instead of <code>ret</code>. In P1, threads need to explicitly call <code>thread_yield</code> which further calls <code>ctx_switch</code>, so the value of register <code>ra</code> saved on the stack by <code>ctx_switch</code> is an address in <code>thread_yield</code>. With this value of <code>ra</code>, <code>ctx_switch</code> can return to <code>thread_yield</code> simply by calling <code>ret</code>. In P2, threads are preempted by a timer interrupt instead of calling any function voluntarily. Therefore, <code>mepc</code> and <code>mret</code> are used to save and restore the program counter.</p><p>The <code>kernel_entry</code> highlighted above is defined in <code>grass/kernel.c</code> and it does 3 things:</p><ul><li><p>Copy <code>mepc</code> and the saved registers of the current thread into its <strong>process control block</strong>, a data structure similar to the thread control block in P1.</p></li><li><p>Pick the next thread by calling <code>proc_yield</code>, a function similar to <code>thread_yield</code> in P1.</p></li><li><p>Restore <code>mepc</code> and the saved registers for the next thread from its process control block.</p></li></ul><h3 id="process-control-block" tabindex="-1">Process control block <a class="header-anchor" href="#process-control-block" aria-label="Permalink to &quot;Process control block&quot;">​</a></h3><p>In addition to the <code>mepc</code> and <code>saved_registers</code> highlighted below, the process control block of egos-2000 is defined in <code>grass/process.h</code> and contains a few other fields:</p><ul><li>a process identifier <code>pid</code></li><li>a data structure for system calls which will be explained in P3</li><li>the <code>status</code> of a process which is closely related to the <strong>lifecycle of a process</strong></li></ul><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> syscall syscall;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proc_status status;</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mepc, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">saved_registers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[SAVED_REGISTER_NUM];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The lifecycle of a process is illustrated by the <code>enum proc_status</code> in <code>grass/process.h</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proc_status {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_UNUSED,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_LOADING,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_READY,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_RUNNING,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_RUNNABLE,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PROC_PENDING_SYSCALL</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* We will explain this one in P3. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Specifically, the <code>status</code> in a <code>struct process</code> would experience the following stages:</p><ol><li>When creating a new process, the <code>status</code> is set from <code>PROC_UNUSED</code> to <code>PROC_LOADING</code>. This happens in the <code>proc_alloc</code> function in <code>grass/process.c</code>.</li><li>The <code>elf_load</code> function in <code>library/elf/elf.c</code> loads the code and data for the process from disk into memory, and then the <code>status</code> is set from <code>PROC_LOADING</code> to <code>PROC_READY</code>. We will explain the details of <code>elf_load</code> in P4 and you can ignore it for now.</li><li>After loading the code and data, the <code>proc_yield</code> in <code>grass/kernel.c</code> will schedule this new process and set the <code>status</code> from <code>PROC_READY</code> to <code>PROC_RUNNING</code>.</li><li>Upon a timer interrupt, the control flow enters <code>proc_yield</code> again and, if it picks another process to run next, the <code>status</code> of the current process will be set from <code>PROC_RUNNING</code> to <code>PROC_RUNNABLE</code>. The <code>status</code> then switches back and forth between <code>PROC_RUNNABLE</code> and <code>PROC_RUNNING</code> because of executing <code>proc_yield</code> upon every timer interrupt.</li><li>When a process terminates, the <code>proc_free</code> function in <code>grass/process.c</code> will be called and <code>proc_free</code> sets the <code>status</code> back to <code>PROC_UNUSED</code>.</li></ol><p>These bullets help you understand the lifecycle of a process. Your first task in this project is to collect some statistics about the lifecycle of every process.</p><h3 id="collect-lifecycle-statistics" tabindex="-1">Collect lifecycle statistics <a class="header-anchor" href="#collect-lifecycle-statistics" aria-label="Permalink to &quot;Collect lifecycle statistics&quot;">​</a></h3><p>Add new fields in <code>struct process</code> and update these fields at the right places, so you can collect the following statistics for every process.</p><ul><li><strong>turnaround time</strong>: the time between process creation and termination</li><li><strong>response time</strong>: the time between process creation and the first time scheduled</li><li><strong>CPU time</strong>: the accumulated time that the process is actually running on the CPU</li><li><strong>number of timer interrupts encountered</strong>: how many times the CPU control flow transfers from the process code to <code>trap_entry</code> due to a timer interrupt</li></ul><p>Process creation, termination and first schedule correspond to bullet 1, 5 and 3 in the above explanation for process lifecycles. To measure time, call the <code>mtime_get</code> function twice and the difference of the two return values is the time elapsed in microsecond (on QEMU). Note that <code>mtime_get</code> is also the function previously used by the timer demo program.</p><p>Print the statistics when a process terminates. Note that the <code>ms</code> below is millisecond (1000 microseconds), and you can assume that all the numbers printed will not overflow the <code>int</code> type (i.e., you can use <code>%d</code> within <code>printf</code> or <code>INFO</code>).</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Hello,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> World!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Hello,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> World!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> terminated</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> after</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> timer</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> interrupts,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> turnaround</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> time:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 174ms,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> response</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> time:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 170ms,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CPU</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> time:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     ../</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     README</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] process 7 terminated after 0 timer interrupts, turnaround time: 233ms, response time: 215ms, CPU time: 1ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> silent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] process 8 terminated after 12 timer interrupts, turnaround time: 1515ms, response time: 233ms, CPU time: 1280ms</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loop</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #499</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] process 9 terminated after 0 timer interrupts, turnaround time: 2269ms, response time: 240ms, CPU time: 1670ms</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Try to explain the different statistics between <code>loop 500</code> and <code>loop 500 silent</code>. For example, why <code>loop 500</code> encounters no timer interrupt and <code>loop 500 silent</code> encounters 12, although the CPU time is close? Note that QEMU can run faster or slower on different machines, so you can see time statistics different from above. The above statistics are printed by running egos-2000 on MacBook Air (M2, 2022) and <a href="https://github.com/xpack-dev-tools/qemu-riscv-xpack/releases/tag/v7.2.5-1" target="_blank" rel="noreferrer">QEMU v7.2.5 released by xPack</a>.</p></div><h3 id="multilevel-feedback-queue" tabindex="-1">Multilevel feedback queue <a class="header-anchor" href="#multilevel-feedback-queue" aria-label="Permalink to &quot;Multilevel feedback queue&quot;">​</a></h3><p>Your final task in this project is to implement the notion of process priority in the scheduler, which is also known as the multilevel feedback queue (MLFQ) scheduler. Specifically, you need to implement a variant of MLFQ with simple rules:</p><ol><li>There are 5 levels, level #0 to #4. All processes start at level #0 when created.</li><li>Processes at level #i can run on the CPU for <code>(i+1)*100</code> milliseconds. For example, if a process at level #0 has run on the CPU for more than 100ms, it will move to level #1. After running for another 200ms, it will move to level #2. Since there are 5 levels, all processes at level #4 will remain at this level without moving further.</li><li>The scheduler in <code>proc_yield</code> should always choose a runnable process with the <strong>lowest level number</strong> (i.e., highest priority) as the next process.</li><li>Every 10 seconds or so, the scheduler in <code>proc_yield</code> should move all processes to level #0. Also, if there is keyboard input for the shell, move <code>GPID_SHELL</code> to level #0.</li></ol><p>Some related definitions have been provided in egos-2000:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_NLEVELS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_RESET_PERIOD</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     10000000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         /* 10 seconds */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MLFQ_LEVEL_RUNTIME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* e.g., 100ms for level 0 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mlfq_update_level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> process</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ulonglong </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">runtime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mlfq_reset_level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">earth-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tty_input_empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ulonglong MLFQ_last_reset_time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Your code goes here. */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>You can implement the MLFQ scheduler by implementing the two functions above and then call these functions in <code>proc_yield</code>. Specifically, add new fields in <code>struct process</code> which record the level and remaining runtime on the level. Assuming that a process <code>p</code> has run for another <code>runtime</code> microseconds, <code>mlfq_update_level</code> updates such fields according to the rule #2 above. When calling this function, reuse your time measurement for CPU time.</p><p>And the <code>mlfq_reset_level</code> function moves processes to level #0 according to the rule #4 above. Use <code>earth-&gt;tty_input_empty()</code> to see whether the shell gets new keyboard input and use the <code>MLFQ_last_reset_time</code> variable to see whether an <code>MLFQ_RESET_PERIOD</code> has elapsed since the last time moving all processes to level #0.</p><p>Lastly, you need to modify the <code>for</code> loop in <code>proc_yield()</code> according to the rule #3 above. Make sure to call <code>proc_try_syscall()</code> for processes with status <code>PROC_PENDING_SYSCALL</code> just like the current code. After you finish, test your code with the shell commands below.</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[CRITICAL] Welcome to the egos-2000 shell</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[INFO] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> running</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> the</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> background</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     ../</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     README</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> killall</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/yunhao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     ../</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     README</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>You can certainly run the commands above with the current scheduler and with your MLFQ scheduler. With the current scheduler, the first <code>ls</code> would take a long time because this <code>ls</code> is interleaved with the background loops. After the <code>killall</code>, <code>ls</code> would become fast again. With your MLFQ scheduler, the two background loops should quickly move to lower priority, so the first <code>ls</code> should be fast just like the second <code>ls</code>. You can confirm such improvement made by MLFQ using the turnaround time printed when <code>ls</code> terminates.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have started to learn about control and status registers which is the key CPU support for operating systems. You will touch more CSRs in later projects. You have also finished reading <code>earth/cpu_intr.c</code>, <code>grass/kernel.s</code> and half of <code>grass/kernel.c</code> in egos-2000.</p></div></div></main><footer class="VPDocFooter" data-v-e6f2a212 data-v-1bcd8184><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/book/p1_ct.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Previous page</span><span class="title" data-v-1bcd8184>P1: Cooperative Threads</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/book/p3_syscall.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>P3: System Call & Protection</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8b57b2d data-v-566314d4><div class="container" data-v-566314d4><p class="message" data-v-566314d4>"... any person ... any study."</p><p class="copyright" data-v-566314d4>Ezra Cornell (1807-1874)</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"book_outcome.md\":\"fgM736Xq\",\"book_overview.md\":\"BtE0wO8l\",\"book_p0_hello.md\":\"CRs-v5gC\",\"book_p1_ct.md\":\"BJ4wI5VO\",\"book_p2_mlfq.md\":\"CM-CgUM1\",\"book_p3_syscall.md\":\"BLWaJlGc\",\"book_p4_vm.md\":\"BayLmSqd\",\"book_p5_sd.md\":\"B2iyipsB\",\"book_p6_file.md\":\"BMKSX_57\",\"book_p7_net.md\":\"CpIaIloR\",\"book_p8_lock.md\":\"Cytpd6sg\",\"index.md\":\"SRIk_n0M\",\"readme.md\":\"BKydlJrD\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"The EGOS book\",\"description\":\"Envision a future where every student can read all the code of a teaching operating system. \",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Vision\",\"link\":\"/\"},{\"text\":\"Overview\",\"link\":\"/book/overview\"}],\"sidebar\":[{\"items\":[{\"text\":\"Overview\",\"link\":\"/book/overview\"},{\"text\":\"P0: Hello, World!\",\"link\":\"/book/p0_hello\"},{\"text\":\"P1: Cooperative Threads\",\"link\":\"/book/p1_ct\"},{\"text\":\"P2: Preemptive Scheduler\",\"link\":\"/book/p2_mlfq\"},{\"text\":\"P3: System Call & Protection\",\"link\":\"/book/p3_syscall\"},{\"text\":\"P4: Virtual Memory\",\"link\":\"/book/p4_vm\"},{\"text\":\"P5: Serial Device Driver\",\"link\":\"/book/p5_sd\"},{\"text\":\"P6: File System\",\"link\":\"/book/p6_file\"},{\"text\":\"P7: Ethernet & TCP/IP\",\"link\":\"/book/p7_net\"},{\"text\":\"P8: Multicore & Locks\",\"link\":\"/book/p8_lock\"},{\"text\":\"The Learning Outcomes\",\"link\":\"/book/outcome\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/yhzhang0128/egos-2000\"}],\"footer\":{\"copyright\":\"Ezra Cornell (1807-1874)\",\"message\":\"\\\"... any person ... any study.\\\"\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>