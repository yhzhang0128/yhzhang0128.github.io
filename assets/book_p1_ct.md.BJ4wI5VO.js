import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.CeQAp18V.js";const n="/assets/p1_ctx.DC0uWUsL.png",u=JSON.parse('{"title":"Cooperative Threads","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"book/p1_ct.md","filePath":"book/p1_ct.md"}'),t={name:"book/p1_ct.md"},h=e(`<h1 id="cooperative-threads" tabindex="-1">Cooperative Threads <a class="header-anchor" href="#cooperative-threads" aria-label="Permalink to &quot;Cooperative Threads&quot;">​</a></h1><p>This project helps you understand the following C program.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Child thread is running.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Main thread is running.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>You have implemented <code>printf</code> in P0 and you will now implement functions <code>thread_init</code>, <code>thread_create</code>, and <code>thread_exit</code> used by this program. Then you shall see its output:</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Possible output #1</span></span>
<span class="line"><span>Child thread is running.</span></span>
<span class="line"><span>Main thread is running.</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Possible output #2</span></span>
<span class="line"><span>Main thread is running.</span></span>
<span class="line"><span>Child thread is running.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The two possibilities demonstrate the concepts of <strong>threads</strong> and <strong>concurrency</strong>. Consider a <strong>thread</strong> as executing a function. Initially, there is only one thread running function <code>main</code>; After <code>main</code> invokes <code>thread_create</code>, another thread is created running function <code>child</code>. Let&#39;s call them the <em>main thread</em> and the <em>child thread</em>. <strong>Concurrency</strong> means that the program does not enforce any ordering between the two threads. Therefore, if the child thread does the printing first, we will observe the first output above. Otherwise, if the main thread does the printing first, we will observe the second possibility.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>We will explain the meaning of <em>cooperative</em> later. The key here is that everything in P1 will only use the three types of CPU instructions explained in P0 (i.e., integer computation, control transfer, and memory access). Again, we have been seriously striving to help you gain a precise understanding of OS concepts (e.g., threads) by connecting the concepts with the exact CPU instructions.</p></div><h2 id="get-started" tabindex="-1">Get started <a class="header-anchor" href="#get-started" aria-label="Permalink to &quot;Get started&quot;">​</a></h2><p>You will start from the <code>thread</code> branch of egos-2000 which provides <code>printf</code> and <code>_sbrk</code> for <code>malloc</code> just like P0. Feel free to incorporate your P0 solutions in <code>thread.c</code> for debug printing. <code>thread.c</code> has also listed all the functions that you need to implement in P1.</p><p>In addition, <code>queue.h</code> and <code>queue.c</code> are added which sketch some code for the queue data structure and can be very useful when you implement the functions in <code>thread.c</code>. You can decide yourself whether to complete the code in <code>queue.c</code> and use the code in <code>thread.c</code>. Completing the code in <code>queue.c</code> is not mandatory.</p><p>Lastly, an important source file is added, namely <code>context.s</code>, which contains two important helper functions <code>ctx_start</code> and <code>ctx_switch</code>:</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ctx_start:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addi </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SAVE_ALL_REGISTERS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sw </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a0)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mv </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,a1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx_entry</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ctx_switch:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addi </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SAVE_ALL_REGISTERS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sw </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a0)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mv </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,a1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RESTORE_ALL_REGISTERS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    addi </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ret</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>The <code>SAVE_ALL_REGISTERS</code> and <code>RESTORE_ALL_REGISTERS</code> are assembly macros with simple definitions in <code>context.s</code>. Next, we explain how to use <code>ctx_start</code> to start the execution of a thread and use <code>ctx_switch</code> to transfer the control flow to a thread that has already been executing. After the explanations, you should be able to implement all the functions used by the multithreaded program above and then run programs with multiple threads.</p><h2 id="context-switch" tabindex="-1">Context switch <a class="header-anchor" href="#context-switch" aria-label="Permalink to &quot;Context switch&quot;">​</a></h2><p>We explain the usage of <code>ctx_start</code> and <code>ctx_switch</code> using one possible execution of the program shown at the beginning:</p><ol><li>The main thread calls <code>thread_create</code>;</li><li>The child thread starts execution, does the printing, and exits;</li><li>The main thread returns from <code>thread_create</code>, does the printing, and exits.</li></ol><p>The picture below illustrates the memory layout during the three steps, which contain the four types of memory regions explained in P0 (i.e., code, data, heap, and stack).</p><p><img src="`+n+`" alt="Failed to load picture"></p><h3 id="what-is-context" tabindex="-1">What is context? <a class="header-anchor" href="#what-is-context" aria-label="Permalink to &quot;What is context?&quot;">​</a></h3><p>In step #1, <code>thread_create</code> is preparing to launch the child thread, and an important part of such preparation is to allocate a piece of memory for the stack of the child thread, shown as the shaded region. Therefore, we now have <strong>two stacks</strong> in the memory which is the key feature of multithreaded programs: <strong>one stack for each thread</strong>.</p><p>The <code>sp</code> in the picture indicates the stack pointer. In step #1, the stack pointer points to the stack of the main thread, and the program counter points to the code of <code>thread_create()</code>. Therefore, we say that the CPU is in the <strong>context</strong> of the main thread. The move from step #1 to step #2 is an example of <strong>context switch</strong>: the stack pointer now points to the stack of the child thread and the program counter points to <code>printf</code>. Therefore, in step #2, the CPU is in the context of the child thread.</p><h3 id="control-flow-details" tabindex="-1">Control flow details <a class="header-anchor" href="#control-flow-details" aria-label="Permalink to &quot;Control flow details&quot;">​</a></h3><p>Here are more details about the control flow from step #1 to step #2, and then to step #3.</p><ul><li><code>thread_create</code> invokes <code>ctx_start</code>, and the <code>ctx_start</code> region in the picture should be 128 bytes (i.e., the first instruction in <code>ctx_start</code> is <code>addi sp,sp,-128</code>). This number 128 is <code>32*4</code> because 32-bit RISC-V defines 32 4-byte registers and <code>SAVE_ALL_REGISTERS</code> is saving the value of all these registers on the stack.</li><li>The <code>sw sp,0(a0)</code> in <code>ctx_start</code> saves the 4-byte value of register <code>sp</code> (i.e., the <code>saved</code> in the picture) at memory address <code>a0</code>, the first argument of <code>ctx_start</code>. The purpose of saving <code>sp</code> at this point is to allow us to switch the CPU context back later.</li><li>The <code>mv sp,a1</code> in <code>ctx_start</code> moves the stack pointer to a memory address specified by <code>a1</code>, the second argument of <code>ctx_start</code>, shown as <code>init sp</code> in the picture.</li><li><code>call ctx_entry</code> invokes the <code>ctx_entry</code> function in <code>thread.c</code>. Intuitively, <code>ctx_entry</code> should find out that the child thread is the one to spawn and therefore it invokes function <code>child</code>. After <code>child</code> returns, <code>ctx_entry</code> should invoke <code>thread_exit</code>.</li><li>Lastly, <code>thread_exit</code> invokes <code>ctx_switch</code> which switches the CPU context back to the main thread. The assembly code of <code>ctx_switch</code> is similar to <code>ctx_start</code>, so try to figure out what is happening during <code>ctx_switch</code>.</li><li>After <code>ctx_start</code> and <code>thread_create</code> both return, the main thread continues to invoke <code>printf</code> and does the printing as shown in step #3 of the picture.</li></ul><p>A few details are still missing: How does <code>thread_create</code> decide the two arguments that it should pass to <code>ctx_start</code>? How does <code>ctx_entry</code> figure out that <code>child</code> is the function to invoke? These questions lead to the concept of Thread Control Block (TCB).</p><h3 id="thread-control-block" tabindex="-1">Thread control block <a class="header-anchor" href="#thread-control-block" aria-label="Permalink to &quot;Thread control block&quot;">​</a></h3><p>The thread control block is a data structure storing the metadata of each thread, including</p><ul><li><em>thread id</em>: a unique identifier of a thread</li><li><em>status</em>: the thread’s current execution status</li><li><em>stack pointer</em>: the saved value of register <code>sp</code> before switching to another thread</li><li><em>entry function</em>: the “main” function of a thread (e.g., <code>child()</code> for the child thread)</li><li><em>entry function arguments</em>: the arguments for the thread’s entry function</li><li>other metadata that could be useful</li></ul><p>You can implement the thread control block as follows.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Design the rest of struct thread yourself.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">TCB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Represent TCB as a simple array. Alternatively,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                       // you can do \`queue_t TCB;\` and use the queue data</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                       // structure functions defined in queue.c.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_idx;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // TCB[current_idx] is the currently running thread.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>The code below shows how to use the TCB for <code>ctx_start</code> in <code>thread_create</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child_stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ctx_start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">TCB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[current_idx].sp, child_stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>TCB[current_idx].sp</code>, as a pointer in a 32-bit program, occupies 4 bytes in the memory. <code>&amp;TCB[current_idx].sp</code> is the address of these 4 bytes, and the <code>sw sp,0(a0)</code> instruction in <code>ctx_start</code> stores the 4 bytes of register <code>sp</code> into <code>TCB[current_idx].sp</code>. Unlike <code>int*</code> which stores the address of an integer, <code>void*</code> is used when we simply need to store a 32-bit memory address without any type information. In this case, we simply need to store the address shown by the text <code>saved</code> in step #2 of the picture above.</p><p>Note that <code>malloc</code> returns the lowest address of the allocated memory, so <code>child_stack + 16 * 1024</code> gives us the highest address shown as <code>init sp</code> in the picture. As the second argument of <code>ctx_start</code>, this value is stored in register <code>a1</code>, and thus <code>mv sp,a1</code> moves the stack pointer from the main thread&#39;s stack to the child thread&#39;s stack.</p><p>Try to figure out how to store and use the entry function in <code>struct thread</code>. You will need the concept of function pointer in C. In short, a function pointer is simply 4 bytes storing the address of a function&#39;s first instruction in the code memory region.</p><h2 id="yield" tabindex="-1">Yield <a class="header-anchor" href="#yield" aria-label="Permalink to &quot;Yield&quot;">​</a></h2><p>Before you start to implement functions <code>thread_init</code>, <code>thread_create</code>, and <code>thread_exit</code>, let us introduce the last function you would implement for multithreading, <code>thread_yield</code>. In the 3-step execution we discussed above, the CPU context would only switch back to the main thread after the child thread exits. However, if the child thread <strong>yields</strong>, the child thread would give up the CPU control and the main thread could resume execution sooner. Here is an example of two threads yielding to each other.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is in for loop i=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, arg, i);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        thread_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(child, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Child thread&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Main thread is in for loop i=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n\\r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        thread_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    thread_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>In this example, both threads do more printing and, because they yield to each other in the loop, we could see interleaving printings from the two threads. Intuitively, the key of an OS is to <strong>insert yields</strong> into different tasks so that different tasks can interleave. In P1, we invoke <code>thread_yield</code> explicitly in different threads just like the code above, and, in P2, we will see how the CPU forces a thread to yield without the thread yielding voluntarily. This difference is why P1 is called <strong>cooperative</strong> threading while P2 is doing <strong>preemptive</strong> threading.</p><p>You can now start to implement the TCB and the following functions in <code>thread.c</code>. Note that <code>struct thread</code> is defined in <code>thread.h</code> which also contains detailed descriptions of these functions. After you finish, you should be able to run the multithreaded programs above and observe the expected output.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ctx_entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread_create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">entry)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread_yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> thread_exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>When all the threads have terminated and therefore no thread from the TCB could run, your code should call <code>_end()</code> which is defined in <code>thread.s</code>. Your code should also free the stack memory of a thread after this thread terminates. This can be tricky because you should not free the stack memory of the currently running thread when this thread still needs its stack for <code>thread_exit()</code> and <code>ctx_switch()</code>. Moreover, the main thread&#39;s stack is not from calling <code>malloc()</code>, so it should not be freed (i.e., when the main thread terminates, do nothing to its stack memory).</p></div><h2 id="conditional-variable" tabindex="-1">Conditional variable <a class="header-anchor" href="#conditional-variable" aria-label="Permalink to &quot;Conditional variable&quot;">​</a></h2><p>In a multithreaded program, threads often need to wait for a certain condition to become true. For example, in your web browser, a thread that renders the webpage on the screen needs to wait until enough network packets for the webpage have been received. Such waiting is typically handled by a synchronization primitive called <strong>conditional variable</strong> which is widely used in real-world software practice. Consider a conditional variable as a variable of type <code>struct cv</code> used by multiple threads with 3 operations:</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Define this data structure yourself */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cv_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cv_signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cv_broadcast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Let <code>cond</code> denote a condition that some threads need to wait for and let <code>cond_cv</code> denote a conditional variable defined in the program for <code>cond</code>. A thread could wait for this condition using a loop <code>while(!cond) cv_wait(&amp;cond_cv);</code>. After such a loop, the thread can assume that condition <code>cond</code> is true and thus proceed with its work. If <code>cond</code> is true right before the loop, the thread will skip the loop without calling <code>cv_wait</code>.</p><p>If <code>cond</code> is false before the loop, the thread will call <code>cv_wait</code> which makes the thread yield. And if no other thread calls <code>cv_signal</code> or <code>cv_broadcast</code> on <code>&amp;cond_cv</code>, the CPU context will never switch back to the waiting thread. The point is that, if another thread finds <code>cond</code> to become true some time later, this other thread can call <code>cv_signal</code> or <code>cv_broadcast</code> on <code>&amp;cond_cv</code> in order to wake up the waiting thread.</p><p>Technically, <code>struct cv</code> should maintain an array or queue of <code>struct thread</code> just like the TCB. Upon <code>cv_wait</code>, the <code>struct thread</code> of the currently running thread is removed from the TCB and added to the conditional variable. This thread will never be switched back to until its <code>struct thread</code> is added back to the TCB. To this end, <code>cv_signal</code> will remove one <code>struct thread</code> from a conditional variable and add it back to the TCB. And <code>cv_broadcast</code> does the same for all <code>struct thread</code> from a conditional variable.</p><p>In this project, we only ask you to implement <code>cv_wait</code> and <code>cv_signal</code>, as well as function <code>cv_init</code> for initializing <code>struct cv</code>, so you can run the following multithreaded program.</p><h2 id="producer-consumer" tabindex="-1">Producer-consumer <a class="header-anchor" href="#producer-consumer" aria-label="Permalink to &quot;Producer-consumer&quot;">​</a></h2><p>A classic problem in computer science is the bounded-buffer producer-consumer problem. In the example below, we have a buffer with a fixed size of 3. A program may spawn many threads, each being a producer or a consumer (i.e., running <code>produce</code> or <code>consume</code> as the entry function). Producers will put items into the buffer and consumers remove items. The constraint is that producers need to wait if the buffer is full and consumers need to wait if the buffer is empty. Therefore, we have two conditional variables <code>nonempty</code> and <code>nonfull</code>, and the associated conditions are highlighted in the code below.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tail </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv nonempty, nonfull;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> produce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cv_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonfull);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // At this point, the buffer is not full.</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[tail] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tail </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (tail </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        cv_signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonempty);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> consume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cv_wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonempty);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // At this point, the buffer is not empty.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[head];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        cv_signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonfull);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>Your job is to implement <code>struct cv</code> and the two operations, wait and signal. You may need to modify the code for TCB and the <code>thread_*</code> functions (e.g., if the current thread invokes <code>thread_yield()</code> in <code>cv_wait()</code>, do not add its <code>struct thread</code> back to the TCB). However, you should not modify the function interface defined in <code>thread.h</code>. After you finish, you can try the above code and add some printing to see what happens.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have finished reading most of <code>grass/kernel.s</code> in egos-2000 which is very similar to <code>ctx_switch</code>. The <code>proc_yield</code> function in <code>grass/kernel.c</code> is similar to <code>thread_yield</code>. You will read and modify <code>proc_yield</code> in P2 and finish reading the rest of <code>grass/kernel.c</code> in P3. Indeed, you will finish reading everything under <code>grass</code> after P3.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Here is a quote from the Wikipedia page for <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" target="_blank" rel="noreferrer">cooperative multitasking</a>, &quot;Cooperative multitasking was the primary scheduling scheme for 16-bit applications employed by Microsoft Windows before Windows 95 and Windows NT, and by the classic Mac OS.&quot;</p></div>`,56),l=[h];function p(r,d,o,c,k,E){return a(),i("div",null,l)}const y=s(t,[["render",p]]);export{u as __pageData,y as default};
