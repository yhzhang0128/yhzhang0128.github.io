import{_ as s,c as i,o as e,a2 as a}from"./chunks/framework.CeQAp18V.js";const n="/assets/VT100.Dwg6Oied.jpg",t="/assets/arty_uart.CJvo0lN_.png",h="/assets/spi.CNWxwkhj.png",r="/assets/pcie_ecam.DL21kpl_.jpg",l="/assets/sdhci.B2F0e-jh.jpg",d="/assets/vga_qemu.DuggBb9l.jpg",f=JSON.parse('{"title":"I/O Device Driver","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"book/p5_io.md","filePath":"book/p5_io.md"}'),p={name:"book/p5_io.md"},o=a('<h1 id="i-o-device-driver" tabindex="-1">I/O Device Driver <a class="header-anchor" href="#i-o-device-driver" aria-label="Permalink to &quot;I/O Device Driver&quot;">​</a></h1><p>At this point, you have finished reading all the kernel code of egos-2000 under the <code>grass</code> directory. You have also finished <code>cpu_intr.c</code> and <code>cpu_mmu.c</code> under the <code>earth</code> directory which handle interrupts, exceptions, and virtual memory.</p><p>In this project, you will read <code>dev_tty.c</code> and <code>dev_disk.c</code> under the <code>earth</code> directory. They contain the driver code for the terminal (keyboard input &amp; screen output) and disk devices. The two files together have fewer than 170 lines of code, but they give good examples of an important concept to learn in this project, <strong>memory-mapped I/O</strong>.</p><h2 id="i-o-bus-and-device" tabindex="-1">I/O bus and device <a class="header-anchor" href="#i-o-bus-and-device" aria-label="Permalink to &quot;I/O bus and device&quot;">​</a></h2><p>An I/O bus connects various devices with the CPU. There are different types of I/O bus, and we introduce three of them connecting the CPU to the terminal and disk devices. In general, computers need to read keyboard input, and print characters on a screen. There used to be a <em>terminal</em> device separate from a computer&#39;s main body handling these functionalities. This photo of the VT100 video terminal was taken at the <a href="https://computerhistory.org/" target="_blank" rel="noreferrer">Computer History Museum</a>.</p><p><img src="'+n+`" alt="Failed to load picture"></p><h3 id="uart-and-terminal" tabindex="-1">UART and terminal <a class="header-anchor" href="#uart-and-terminal" aria-label="Permalink to &quot;UART and terminal&quot;">​</a></h3><p>In egos-2000, a terminal is connected to the CPU using <strong>Universal Asynchronous Receiver/Transmitter</strong> (UART). UART involves only two hardware pins on the CPU -- one for <em>receiving</em> bytes and the other for sending (i.e., <em>transmiting</em>) bytes.</p><p>When pressing a key on the keyboard, the terminal sends the corresponding character as a byte through UART to the CPU, and the operating system reads this byte from the <em>Receiver</em> hardware pin. When the operating system prints a character, it sends out a byte through the CPU&#39;s <em>Transmitter</em> hardware pin, and UART will pass the byte to the terminal. <em>Asynchronous</em> in UART means that electrical signals on the two hardware pins do not wait for each other.</p><p>The code below shows how egos-2000 connects to a terminal device using UART.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UART_BASE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LINE_STATUS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UL</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uart_getc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, LINE_STATUS) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uart_putc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, LINE_STATUS) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UART_BASE, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>The CPU uses the special memory address <code>0x10000000</code> to communicate with the terminal. When receiving a byte, bit#0 of the line status register at <code>0x10000005</code> will be set to 1 by the CPU. After detecting such a byte, <code>uart_getc</code> reads it from memory address <code>0x10000000</code>. When sending a byte, <code>uart_putc</code> waits for UART to be idle (i.e., UART finishes sending the previous byte) by checking bit#5 of the line status register. After UART is ready, <code>uart_putc</code> writes to address <code>0x10000000</code> the byte to be printed on the terminal screen.</p><p>The code looks simple because most of the complexities are handled by the hardware. For example, when running egos-2000 on a RISC-V board, and using the <code>screen</code> command on MacOS as the terminal, the <em>UART/USB bridge</em> chip labeled below will convert the electrical signals between UART and <strong>Universal Serial Bus</strong> (USB) so that egos-2000 does not have to handle the complexity of USB. In many operating systems, the driver code for USB could be a lot more complicated than the code for UART above.</p><p><img src="`+t+'" alt="Failed to load picture"></p><p>This UART driver code is also an example of <strong>memory-mapped I/O</strong>. Specifically, a hardware manufacturer can define special memory regions used to control I/O devices, and different manufacturers can define different regions. Indeed, egos-2000 can run on both QEMU and RISC-V boards which use different regions for UART. As shown in <code>library/egos.h</code>, RISC-V boards use the memory region starting at <code>0xF0001000</code> to control UART. The driver code for RISC-V boards is also slightly different from the code for QEMU in <code>dev_tty.c</code>.</p><h3 id="spi-and-sd-card" tabindex="-1">SPI and SD card <a class="header-anchor" href="#spi-and-sd-card" aria-label="Permalink to &quot;SPI and SD card&quot;">​</a></h3><p>A computer typically needs a disk storing blocks of data when the computer is powered off, and egos-2000 uses an <a href="https://www.sdcard.org" target="_blank" rel="noreferrer">SD card</a> as the disk.</p><p>On a RISC-V board, an SD card is connected with the CPU using <strong>Serial Peripheral Interface</strong> (SPI) which has four hardware pins on the CPU, two more pins than UART. <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface" target="_blank" rel="noreferrer">The picture from Wikipedia</a> illustrates the four hardware pins.</p><p><img src="'+h+`" alt="Failed to load picture"></p><p>Consider the CPU as the <em>SPI Main</em> and the SD card device as the <em>SPI Sub</em>. Both sides have four hardware pins, and their functionalities are described below.</p><ul><li><strong>Chip Select (CS)</strong> resets the SD card before starting to use it.</li><li><strong>Serial Clock (SCLK)</strong> provides clock signals from the CPU (e.g., 20MHz).</li><li><strong>Main Out Sub In (MOSI)</strong> is used by the CPU to send bytes to the SD card.</li><li><strong>Main In Sub Out (MISO)</strong> is used by the SD card to send bytes to the CPU.</li></ul><p>Similar to UART, the CPU provides memory-mapped I/O regions for communicating with the SD card through SPI. Different from UART, the SPI Main and SPI Sub <em>exchange</em> bytes during communication. The code below explains how it works.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* The &quot;exchange&quot; here means sending a byte and then receiving a byte. */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDSPI_BASE, LITEX_SPI_MOSI)    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> byte;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDSPI_BASE, LITEX_SPI_CONTROL) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDSPI_BASE, LITEX_SPI_STATUS) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDSPI_BASE, LITEX_SPI_MISO) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>First, <code>byte</code> is sent out through the <code>MOSI</code> pin. You can ignore <code>LITEX_SPI_CONTROL</code> which is hardware specific. After sending <code>byte</code>, SPI immediately receives a byte from the <code>MISO</code> pin (i.e., from the SD card) as the return value of <code>spi_exchange</code>. The <code>while</code> loop waits for the arrival of a byte just like the loop in <code>uart_getc</code>. The difference is that SPI always receives a byte after sending a byte (i.e., synchronous), while UART is asynchronous.</p><p>While <code>spi_exchange</code> uses the <code>MOSI</code> and <code>MISO</code> SPI pins, the code below controls the clock signals sent out to the <code>SCLK</code> pin from the CPU.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CPU_CLOCK_RATE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100000000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 100MHz */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">INFO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Set the SPI clock to 20MHz for the SD card&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDSPI_BASE, LITEX_SPI_CLKDIV) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CPU_CLOCK_RATE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20000000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>As an exercise, read the <code>sdspi_init</code> function in <code>dev_disk.c</code> from which you will see how <code>SCLK</code> is controlled during the initialization of an SD card.</p></div><p>An SD card command has 6 bytes so that the operating system can ask the SD card to do a certain task by sending the corresponding 6-byte command using <code>spi_exchange</code>. Given an SD card command, the <code>sdspi_exec_cmd</code> function sends the 6 bytes, and waits for the reply from SD card until a timeout.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sdspi_exec_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Send a 6-byte SD card command through the SPI bus. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    #define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TIME_OUT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reply, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TIME_OUT; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((reply </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reply;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="read-an-sd-card-block" tabindex="-1">Read an SD card block <a class="header-anchor" href="#read-an-sd-card-block" aria-label="Permalink to &quot;Read an SD card block&quot;">​</a></h3><p>The SD card command #17 is defined for reading a block. An SD card <strong>block</strong> is typically 512 bytes -- when reading or writing an SD card, the operating system will read or write a 512-byte block altogether. This is different from the terminal device which reads or writes in the granularity of a single byte.</p><p>Given <code>sdspi_exec_cmd</code>, the <code>sdspi_read</code> function below reads a block from the SD card to memory address <code>dst</code>, and the <code>offset</code> argument decides which block should be read. For example, if <code>offset</code> is 0, <code>sdspi_read</code> will read the very first block on the SD card.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sdspi_read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Wait until SD card is ready for a new command. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Send a read request with command #17. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">offset;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reply, cmd17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (reply </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sdspi_exec_cmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cmd17)) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FATAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cmd17 returns non-zero status&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Wait for the 512-byte block, and ignore the 2-byte checksum. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line highlighted"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BLOCK_SIZE; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dst</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spi_exchange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>On the high level, the code above proceeds with the following steps.</p><ul><li>Wait for the SD card device to be ready for the next command.</li><li>Send command #17 to the SD card. Out of the 6 bytes, the 4 bytes in the middle encode a block number (i.e., <code>offset</code>) indicating which block should be read.</li><li>Wait for the SD card device to be ready to send back the 512-byte block data.</li><li>Receive 512 bytes from the SD card as the block data together with a 2-byte checksum.</li></ul><p>At this point, we have shown a concrete example of controlling an SD card device using SPI with a good amount of hardware details of SPI. Beyond this point, we focus on the memory-mapped I/O interface alone because the hardware pins and signals become complicated.</p><h3 id="pcie-and-plug-and-play" tabindex="-1">PCIe and plug-and-play <a class="header-anchor" href="#pcie-and-plug-and-play" aria-label="Permalink to &quot;PCIe and plug-and-play&quot;">​</a></h3><p>While SPI provides a simple way of using an SD card, there are two constraints.</p><ol><li><p>SPI devices typically need manual setup and cannot be automatically detected.</p></li><li><p>Reading the 512-byte block data byte-by-byte through <code>spi_exchange</code> is very slow.</p></li></ol><p>To address such problems, we introduce <strong>Plug-and-Play</strong> and <strong>Direct Memory Access</strong> (DMA). Plug-and-Play allows the operating system to detect a new device connected with the CPU, and configure memory-mapped I/O regions for the new device. DMA allows the hardware to read and write the memory directly so that an SD card can write the block data into memory without the CPU having to run <code>spi_exchange</code> in a loop of 512 times.</p><p>Plug-and-Play and DMA are made possible by <strong>Peripheral Component Interconnect</strong> (PCI) or its successor PCIe. In egos-2000, the memory region starting at <code>0x30000000</code> controls PCIe which connects with multiple devices. The operating system controls device #i on PCIe by reading or writing the memory region <code>[0x30000000+0x8000*i, 0x30000000+0x8000*(i+1))</code>. For example, the <code>addr=0x1</code> in the definition of <code>QEMU_SD_CARD</code> in <a href="https://github.com/yhzhang0128/egos-2000/blob/main/Makefile" target="_blank" rel="noreferrer">the Makefile</a> indicates that an SD card is inserted as device #1 on the PCIe bus. Therefore, the memory at <code>0x30008000</code> is used to control this SD card (i.e., <code>SDHCI_PCI_ECAM</code> in <code>library/egos.h</code>). The table below is from <a href="https://wiki.osdev.org/PCI" target="_blank" rel="noreferrer">a wiki page for PCI</a>, and it shows how to interpret the memory at <code>0x30008000</code>.</p><p><img src="`+r+'" alt="Failed to load picture"></p><p>The first 4 bytes at <code>0x30008000</code> provide the <em>Vendor ID</em> and <em>Device ID</em> for device #1 on PCIe. Based on the two ID numbers, an operating system learns that device #1 is an SD card. This is essentially how Plug-and-Play works: the operating system periodically reads the 4 bytes at <code>0x30000000</code> (device #0), <code>0x30008000</code> (device #1), <code>0x30010000</code> (device #2), and so on. According to the two ID numbers, the operating system learns whether a device is plugged in or plugged out at a PCIe address. Later in this project, you will modify the <code>QEMU_GRAPHIC</code> in <a href="https://github.com/yhzhang0128/egos-2000/blob/main/Makefile" target="_blank" rel="noreferrer">the Makefile</a>, and plug in a VGA device as device #2 on the PCIe bus.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>As an exercise, read the first two lines of the <code>sdhci_init</code> function in <code>dev_disk.c</code>. They modify <em>Command</em> (0x4) and <em>Base address #0</em> (0x10) according to the table above. Understand these two lines of code, especially the <em>Memory Space</em> and <em>Bus Master</em> bits, by reading <a href="https://wiki.osdev.org/PCI" target="_blank" rel="noreferrer">the wiki page for PCI</a>.</p></div><h2 id="sd-host-controller-interface" tabindex="-1">SD host controller interface <a class="header-anchor" href="#sd-host-controller-interface" aria-label="Permalink to &quot;SD host controller interface&quot;">​</a></h2><p>The PCIe bus provides an advanced memory-mapped I/O interface for SD cards called the <strong>Secure Digital Host Controller Interface</strong> (SDHCI). An example of using SDHCI in egos-2000 is the <code>sdhci_read</code> function in <code>dev_disk.c</code> which reads a block with the command #17 just like <code>sdspi_read</code>, but <code>sdhci_read</code> uses the DMA feature in the SDHCI specification.</p><h3 id="sdhci-specification" tabindex="-1">SDHCI specification <a class="header-anchor" href="#sdhci-specification" aria-label="Permalink to &quot;SDHCI specification&quot;">​</a></h3><p>The <a href="https://www.sdcard.org" target="_blank" rel="noreferrer">SD Association</a> maintains the official SDHCI specification just like RISC-V International maintains the <a href="https://riscv.org/specifications/ratified/" target="_blank" rel="noreferrer">ratified ISA specifications</a> of RISC-V. In this project, you will need Chapter 2.1 and 2.2 of the <a href="assets/PartA2_SDHost_Controller_Simplified_Specification_Ver4.20.pdf">SD Host Controller Simplified Specification</a>. Table 2-1 in Chapter 2.1.1 shows the SDHCI register map, and the screenshot below shows part of this table which is enough to understand the <code>sdhci_read</code> function.</p><p><img src="'+l+`" alt="Failed to load picture"></p><h3 id="direct-memory-access" tabindex="-1">Direct memory access <a class="header-anchor" href="#direct-memory-access" aria-label="Permalink to &quot;Direct memory access&quot;">​</a></h3><p>The first few lines of <code>sdhci_read</code> prepare direct memory access.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Prepare DMA (SDMA mode of SDHCI). */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">aligned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BLOCK_SIZE))) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> aligned_buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[BLOCK_SIZE];</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDHCI_BASE, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)aligned_buf;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">REGW</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SDHCI_BASE, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BLOCK_SIZE;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>According to the table above, the address of a 512-byte buffer <code>aligned_buf</code> is written to the <em>SDMA System Address</em> register at <code>000h</code>. The <em>Block Size</em> register at <code>004h</code> is written by <code>BLOCK_SIZE</code>, and the <em>16-bit Block Count</em> register at <code>006h</code> is written by <code>1</code>. Together, these values indicate that <code>sdhci_read</code> asks SDHCI to write <code>1</code> block of <code>BLOCK_SIZE</code> bytes to the buffer <code>aligned_buf</code> when executing the upcoming SD card read command.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Read the rest of <code>sdhci_read</code> and the <code>sdhci_exec_cmd</code> function by referencing the table above. The code shows how to issue SD card command #17 by writing to the <em>Argument</em> register at <code>008h</code>, the <em>Transfer Mode</em> register at <code>00Ch</code>, and the <em>Command</em> register at <code>00Eh</code>. It further shows how to wait for the SD card command #17 to finish after which the 512-byte block data should be ready in <code>aligned_buf</code> given how we have prepared DMA.</p></div><p>Chapter 2.2 of the <a href="assets/PartA2_SDHost_Controller_Simplified_Specification_Ver4.20.pdf">specification</a> explains the details of all the registers in Table 2-1. You are encouraged to study the difference between <em>Single Operation DMA</em> (SDMA) and <em>Advanced DMA</em> (ADMA) by reading more of the specification or asking ChatGPT. For example, you will learn that a constraint of SDMA is that the DMA buffer cannot span across multiple memory pages. By making the DMA buffer aligned by <code>BLOCK_SIZE</code>, the code above guarantees that all the 512 bytes of <code>aligned_buf</code> are in the same 4KB memory page. With this constraint in mind, we now ask you to implement a better version of the SD card driver.</p><h2 id="read-and-write-multiple-blocks" tabindex="-1">Read and write multiple blocks <a class="header-anchor" href="#read-and-write-multiple-blocks" aria-label="Permalink to &quot;Read and write multiple blocks&quot;">​</a></h2><p>Our driver code uses the SD card command #17 to read a single block, and the <code>disk_read</code> function simply calls <code>sdhci_read</code> or <code>sdspi_read</code> multiple times within a loop.</p><p>The SD card standard provides command #18 and #25 for reading and writing consecutive blocks altogether. Your job is to replace the loop in <code>disk_read</code> and implement <code>disk_write</code> with your own SD card driver using SD command #18 and #25. The details of command #18 and #25 can be found in <a href="http://elm-chan.org/docs/mmc/mmc_e.html" target="_blank" rel="noreferrer">this blog</a> while you can certainly find other materials about the two SD card commands online.</p><p>Start with the driver for SDHCI which runs on QEMU. After you finish, egos-2000 should be able to run normally. It would be very useful and important to write unit tests for your driver code. For example, instead of booting egos-2000, you can run your unit tests right after the call to <code>disk_init()</code> in <code>boot()</code> of <code>earth/boot.c</code>. The test code should write and read the 4MB SD card multiple times, and check whether the code behavior is expected. If you have a RISC-V board, you can further implement the driver code for the SPI bus.</p><h2 id="plug-in-a-vga-device-on-pcie" tabindex="-1">Plug in a VGA device on PCIe <a class="header-anchor" href="#plug-in-a-vga-device-on-pcie" aria-label="Permalink to &quot;Plug in a VGA device on PCIe&quot;">​</a></h2><p>To learn more about device drivers, you will now plug in a VGA device on the PCIe bus, and write the driver code initializing this device. The goal is to ensure <code>apps/user/video_demo.c</code> can work on QEMU as shown in this screenshot.</p><p><img src="`+d+'" alt="Failed to load picture"></p><p>To start with, update the <code>QEMU_GRAPHIC</code> in the Makefile as <code>-device VGA,addr=0x2 -serial mon:stdio</code> which plugs in a VGA device as device #2 on PCIe. The rest of your code should be in <code>boot()</code> of <code>earth/boot.c</code>. From <a href="https://www.qemu.org/docs/master/specs/standard-vga.html" target="_blank" rel="noreferrer">QEMU&#39;s document for this VGA device</a>, you can find the &quot;PCI spec&quot; of this device as follows.</p><ul><li><strong>PCI Region 0:</strong> Framebuffer memory, 16 MB in size (by default).</li><li><strong>PCI Region 2:</strong> MMIO bar, 4096 bytes in size (QEMU 1.3+)</li></ul><p>This means that you need to initialize both <em>base address #0</em> and <em>base address #2</em> of device #2&#39;s PCI configuration. The first address has been defined for you as <code>VIDEO_FRAME_BASE</code> in <code>library/egos.h</code>, and it has been used by <code>video_demo</code> to set the RGB value of each pixel.</p><p>Your job is to define the address for base address #2, and initialize the memory-mapped I/O region according to the &quot;MMIO area spec&quot; section of <a href="https://www.qemu.org/docs/master/specs/standard-vga.html#mmio-area-spec" target="_blank" rel="noreferrer">QEMU&#39;s document</a>. The &quot;vga ioports&quot; and &quot;bochs dispi interface registers&quot; in this section are not really well explained, so search for more information yourself. The comments in <code>boot()</code> provide some hints and guidance.</p><p>Your driver code only runs on QEMU because the VGA/HDMI device on the RISC-V boards does not require any driver code to run <code>video_demo</code>. If you have a board such as the $35 Tang Nano 20K, and you are more interested in designing a <strong>Graphical User Interface</strong> (GUI) for egos-2000, you can directly run your GUI design on your board without worrying about the VGA driver at all. You simply need a monitor and a VGA or HDMI cable.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have learned <strong>memory-mapped I/O</strong> and three types of <strong>I/O bus</strong> by reading the device driver code in egos-2000. The SDHCI driver gives a concrete example of <strong>direct memory access</strong>. You have also written some driver code for an SD card and a VGA display device.</p>',69),k=[o];function c(g,E,y,m,u,b){return e(),i("div",null,k)}const C=s(p,[["render",c]]);export{f as __pageData,C as default};
