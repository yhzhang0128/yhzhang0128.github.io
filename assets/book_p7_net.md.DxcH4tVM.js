import{_ as e,c as s,o as a,a2 as n}from"./chunks/framework.CeQAp18V.js";const i="/assets/vnet.RevcCUg5.png",b=JSON.parse('{"title":"Ethernet & TCP/IP","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"book/p7_net.md","filePath":"book/p7_net.md"}'),t={name:"book/p7_net.md"},r=n('<h1 id="ethernet-tcp-ip" tabindex="-1">Ethernet &amp; TCP/IP <a class="header-anchor" href="#ethernet-tcp-ip" aria-label="Permalink to &quot;Ethernet &amp; TCP/IP&quot;">​</a></h1><p>Modern operating systems enable users to connect to computer networks through <strong>Ethernet</strong> or Wi-Fi, and the most widely used computer network is the Internet. On the Internet, some computers run a web server that hosts web pages, while others run a browser that obtains and displays web pages. Communication between a web server and web browsers typically relies on the <strong>TCP/IP</strong> protocol.</p><p>In this project, you will gain hands-on experience with the Intel Gigabit Ethernet Controller, and you will learn how an operating system like egos-2000 transmits and receives network packets. With Ethernet working, you will learn how to communicate using the <strong>UDP</strong> protocol, a component of TCP/IP. Lastly, we explain some open-ended possibilities of implementing a web server that adopts the complete TCP/IP protocol.</p><h2 id="create-a-virtual-network" tabindex="-1">Create a virtual network <a class="header-anchor" href="#create-a-virtual-network" aria-label="Permalink to &quot;Create a virtual network&quot;">​</a></h2><p>This project uses a simple network topology of two machines connected to Ethernet. The <em>Mac/Linux</em> box refers to your work machine on which you run QEMU. The <em>EGOS</em> box refers to the <code>virt</code> RISC-V machine emulated within QEMU, which runs egos-2000. Your first task is to create an Ethernet network connecting the two. Instead of using Ethernet cables and routers, you will create an emulated network with QEMU-based software tools (i.e., a <em>virtual network</em>). After you finish this project, you can port your code to the Arty A7 boards with a physical Ethernet controller and an Ethernet slot (i.e., a LAN port).</p><p><img src="'+i+`" alt="Failed to load picture"></p><p>Creating a virtual network involves different steps on MacOS and Linux. We thus explain the steps separately, and you will touch on the concepts of <strong>MAC address</strong> and <strong>IP address</strong>.</p><h4 id="macos" tabindex="-1">MacOS <a class="header-anchor" href="#macos" aria-label="Permalink to &quot;MacOS&quot;">​</a></h4><p>All you need to do is change one line in the Makefile while <code>QEMU_ETHERNET_MACOS</code> has been defined for you.</p><div class="language-diff vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">diff</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">- $(QEMU) $(QEMU_MACHINE) $(QEMU_GRAPHIC) $(QEMU_FLASH_1) $(QEMU_SD_CARD)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">+ sudo $(QEMU) $(QEMU_MACHINE) $(QEMU_GRAPHIC) $(QEMU_FLASH_1) $(QEMU_SD_CARD) $(QEMU_ETHERNET_MACOS)</span></span></code></pre></div><p>MacOS provides the <code>ifconfig</code> command with which you can inspect the virtual network controller created by QEMU. Specifically, after you run <code>make qemu</code> and type your password for <code>sudo</code>, run the following command in a separate terminal.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; ifconfig -a</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bridge100: flags=8a63&lt;UP,BROADCAST,SMART,RUNNING,ALLMULTI,SIMPLEX,MULTICAST&gt; mtu 1500</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  options=3&lt;RXCSUM,TXCSUM&gt;</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  ether ae:c9:06:72:b2:64</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  inet 192.168.18.1 netmask 0xffffff00 broadcast 192.168.18.255</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  inet6 fe80::acc9:6ff:fe72:b264%bridge100 prefixlen 64 scopeid 0x16</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  inet6 fd64:5a7b:bd1e:741a:97:e7a7:bede:7f67 prefixlen 64 autoconf secured</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  Configuration:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ipfilter disabled flags 0x0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  member: vmenet0 flags=3&lt;LEARNING,DISCOVER&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          ifmaxaddr 0 port 21 priority 0 path cost 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  nd6 options=201&lt;PERFORMNUD,DAD&gt;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  media: autoselect</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  status: active</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>This is the virtual network controller device created by QEMU on MacOS. If you quit QEMU, this virtual device will disappear. The two lines highlighted show the MAC and IP addresses. The MAC address has 6 bytes shown in hexadecimal form. <code>0xae</code> is the lowest byte in this MAC address, and <code>0x64</code> is the highest. The IP address has 4 bytes shown as 4 numbers in the range <code>[0, 255]</code>. <code>192</code> is the highest byte, and <code>1</code> is the lowest.</p><h4 id="linux-ubuntu" tabindex="-1">Linux (Ubuntu) <a class="header-anchor" href="#linux-ubuntu" aria-label="Permalink to &quot;Linux (Ubuntu)&quot;">​</a></h4><p>While QEMU creates a virtual network controller (i.e., <code>bridge100</code>) automatically on MacOS, you need to create it manually on Linux. The steps below are provided in <a href="https://github.com/p-shah256/egos-project" target="_blank" rel="noreferrer">a student project</a>, which targets Ubuntu. You may need to search for more information yourself.</p><ul><li>Install <code>qemu-system</code> which gives you <code>/usr/lib/qemu/qemu-bridge-helper</code>. Note that it is used in the definition of <code>QEMU_ETHERNET_LINUX</code> in the Makefile. <code>net-tools</code> downloads the <code>ifconfig</code> command on Ubuntu.</li></ul><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo apt-get install qemu-system net-tools</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>We will use the <code>qemu-bridge-helper</code> to communicate between egos-2000 and Ubuntu via a bridge called <code>virbr0</code>. The commands below create <code>virbr0</code> for the bridge helper.</li></ul><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo chmod u+s /usr/lib/qemu/qemu-bridge-helper</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; mkdir /etc/qemu</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo chmod 755 /etc/qemu</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; touch /etc/qemu/bridge.conf</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo chmod 644 /etc/qemu/bridge.conf</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; echo </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;allow virbr0&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tee</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/qemu/bridge.conf</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo ip link add virbr0 type bridge</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo ip link set dev virbr0 up</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo ip addr add 192.168.18.1/24 dev virbr0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>Inspect the virtual Ethernet controller <code>virbr0</code> with <code>ifconfig</code>.</li></ul><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; ifconfig -a</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        inet 192.168.18.1  netmask 255.255.255.0  broadcast 0.0.0.0</span></span>
<span class="line highlighted"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        ether 52:54:00:9d:14:bd  txqueuelen 1000  (以太网)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        RX packets 9  bytes 468 (468.0 B)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        RX errors 0  dropped 0  overruns 0  frame 0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        TX packets 12  bytes 622 (622.0 B)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>Update the Makefile.</li></ul><div class="language-diff vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">diff</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;">- $(QEMU) $(QEMU_MACHINE) $(QEMU_GRAPHIC) $(QEMU_FLASH_1) $(QEMU_SD_CARD)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">+ sudo $(QEMU) $(QEMU_MACHINE) $(QEMU_GRAPHIC) $(QEMU_FLASH_1) $(QEMU_SD_CARD) $(QEMU_ETHERNET_LINUX)</span></span></code></pre></div><p>Note that the <code>br=virbr0</code> in <code>QEMU_ETHERNET_LINUX</code> means that QEMU will use this manually created virtual Ethernet controller called <code>virbr0</code>.</p><h2 id="map-ip-and-mac-address" tabindex="-1">Map IP and MAC address <a class="header-anchor" href="#map-ip-and-mac-address" aria-label="Permalink to &quot;Map IP and MAC address&quot;">​</a></h2><p>Take a look at the <code>struct ethernet_header</code> in <code>apps/user/udp_demo.c</code>.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ethernet_header {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uchar </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">destmac</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    uchar </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">srcmac</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ushort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ethertype;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">__attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Suppose egos-2000 with MAC address <code>52:54:00:12:34:56</code> sends a 64-byte message to your MacOS with MAC address <code>ae:c9:06:72:b2:64</code>. Here is what happens.</p><ol><li><p>egos-2000 puts the 14-byte <code>struct ethernet_header</code> before the 64-byte message, and set the <code>destmac</code> and <code>srcmac</code> as <code>ae:c9:06:72:b2:64</code> and <code>52:54:00:12:34:56</code>.</p></li><li><p>egos-2000 gives the 78 bytes to the Ethernet controller (i.e., the E1000 device emulated by QEMU), and the Ethernet controller will broadcast these 78 bytes on Ethernet.</p></li><li><p>The Ethernet controller on MacOS named <code>bridge100</code> receives the 78 bytes, and checks that the <code>destmac</code> encoded matches its MAC address <code>ae:c9:06:72:b2:64</code>. The Ethernet controller thus knows that it is the destination for this network message.</p></li></ol><p>If all we need is to communicate in the local Ethernet network, the steps above are enough. However, the Internet uses IP addresses to identify senders and receivers, where IP stands for the <strong>Internet Protocol</strong>. Many network tools are based on IP, so we need to tell MacOS or Linux how to map the IP address of a machine to the MAC address of that machine.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># On MacOS</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -d -i bridge100 -a</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># On Linux</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -d -i virbr0 192.168.18.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -d -i virbr0 192.168.18.2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># On both, and use virbr0 instead of bridge100 on Linux</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -s 192.168.18.1 ae:c9:06:72:b2:64 -i bridge100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -s 192.168.18.2 52:54:00:12:34:56 -i bridge100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo arp -a -i bridge100</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">? (192.168.18.1) at ae:c9:6:72:b2:64 on bridge100 ifscope permanent [bridge]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">? (192.168.18.2) at 52:54:0:12:34:56 on bridge100 permanent [bridge]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>The <code>arp</code> is a built-in command for this purpose. The commands above tell your MacOS or Linux that, for messages sent to IP address <code>192.168.18.2</code>, use <code>52:54:0:12:34:56</code> as the destination MAC address in the Ethernet header. Similarly, the machine with the IP address <code>192.168.18.1</code> has MAC address <code>ae:c9:6:72:b2:64</code>.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Make sure to examine the output of <code>sudo arp -a -i bridge100</code> carefully. If the mappings from IP to MAC addresses are wrong or incomplete, network communications in this project will likely fail.</p></div><h2 id="run-a-simple-udp-program" tabindex="-1">Run a simple UDP program <a class="header-anchor" href="#run-a-simple-udp-program" aria-label="Permalink to &quot;Run a simple UDP program&quot;">​</a></h2><p>Now is a good time to read through <code>apps/user/udp_demo.c</code>. For example, you can find that <code>struct ip_header</code> holds <code>src_ip</code> and <code>dst_ip</code>, which are assigned by <code>192.168.18.2</code> and <code>192.168.18.1</code> in the <code>main</code> function. In this demo program, <strong>User Datagram Protocol</strong> (UDP) sends a string <code>Hello from egos-2000!\\n\\r</code> from egos-2000 (i.e., <code>192.168.18.2</code>) to Linux or MacOS (i.e., <code>192.168.18.1</code>).</p><p>After creating a virtual network, your second task in this project is to modify the source and destination addresses at the start of this demo program, so it works on your work machine. Again, you can use <code>ifconfig</code> to inspect the destination IP and MAC addresses. In QEMU, you can do <code>Ctrl+a</code> and then <code>c</code> to enter the QEMU shell, and then type <code>info network</code> in the QEMU shell. The <code>macaddr</code> below is the MAC address of the E1000 network controller.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[CRITICAL] Welcome to the egos-2000 shell!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">➜ /home/yunhao QEMU 8.2.6 monitor - type </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;help&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> more information</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(qemu) info network</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">e1000.0: index=0,type=nic,model=e1000,macaddr=52:54:00:12:34:56</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\ E1000: index=0,type=vmnet-host,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(qemu)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>After setting the source and destination addresses correctly, open two terminals, and use the <code>nc</code> network tool to receive the UDP message in your MacOS or Linux.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># In terminal </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[CRITICAL] Welcome to the egos-2000 shell!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">➜ /home/yunhao udp_demo</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># In terminal </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; nc -u -l 192.168.18.1 8002</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Hello from egos-2000!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>In the <code>nc</code> command, <code>-u</code> means using UDP, and <code>-l</code> means listening. You can also run the <code>tcpdump</code> command. For example, right before running <code>udp_demo</code> in egos-2000, run <code>sudo tcpdump -e -i bridge100</code> in another terminal. You should see the printing below with the addresses and the <code>UDP, length 24</code>.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; sudo tcpdump -e -i bridge100</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14:57:27.269551 52:54:00:12:34:56 (oui Unknown) &gt; ae:c9:06:72:b2:64 (oui Unknown), ethertype IPv4 (0x0800), length 66: 192.168.18.2.vcom-tunnel &gt; 192.168.18.1.teradataordbms: UDP, length 24</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>The <code>bridge100</code> in the above commands refers to the virtual network controller interface shown in the output of <code>ifconfig -a</code> on MacOS. Replace it with <code>virbr0</code> on Linux.</p></div><h2 id="receive-data-from-ethernet" tabindex="-1">Receive data from Ethernet <a class="header-anchor" href="#receive-data-from-ethernet" aria-label="Permalink to &quot;Receive data from Ethernet&quot;">​</a></h2><p>After learning how to send a UDP message from egos-2000 through Ethernet, you will write the driver code for receiving messages. Specifically, when <code>nc</code> sends a UDP message from Linux or MacOS to egos-2000, the Intel Gigabit Ethernet Controller will send an <em>I/O interrupt</em> to the <strong>Platform-Level Interrupt Controller</strong> (PLIC) component of the RISC-V CPU emulated in QEMU. Your driver code needs to enable interrupts from the Ethernet controller and handle these interrupts in the <code>intr_entry</code> function of <code>grass/kernel.c</code>, where timer interrupts are currently handled. When handling an I/O interrupt from Ethernet, you will print the metadata and data of the received Ethernet frame, especially the UDP message.</p><h3 id="enable-interrupts-in-plic" tabindex="-1">Enable interrupts in PLIC <a class="header-anchor" href="#enable-interrupts-in-plic" aria-label="Permalink to &quot;Enable interrupts in PLIC&quot;">​</a></h3><p>Enabling I/O interrupts for the Intel Gigabit Ethernet Controller involves two steps. The first step is simply to set the <code>MEIE</code> bit of the <code>mie</code> CSR just like setting <code>mie.MTIE</code> enables timer interrupts according to chapter 3.1.9 of <a href="assets/riscv-privileged-20241101.pdf">the RISC-V reference manual</a>. Just like the handling of timer interrupt, this allows the CPU control flow to enter <code>intr_entry</code> with <code>id==11</code> upon an I/O interrupt (aka. external interrupt). However, this does not tell the kernel <em>which</em> device sends the I/O interrupt, and we need to learn that through PLIC and the concept of <strong>Interrupt Request</strong> (IRQ). Consider IRQ as a number in the range <code>[0, 1023]</code>, and PLIC associates an IRQ number with every device.</p><p>The second step is to learn the IRQ number of the Ethernet controller and enable interrupts from this IRQ in PLIC. It is your job to figure out the details, but here are some hints.</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PLIC_PRIORITY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">irq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)     (PLIC_BASE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (irq))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PLIC_ENABLE_BASE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (PLIC_BASE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (core))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PLIC_CAUSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">core</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)       (PLIC_BASE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200004</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (core))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The first macro is used to set the priority of an IRQ, and the second is the base address of a bitmap controlling whether an IRQ is enabled for a CPU core. Modify the <code>QEMU_MACHINE</code> in Makefile, and use <code>-smp 1</code> instead of <code>-smp 4</code>, so you will only need to enable the interrupt for core #0. The third macro gives the IRQ number of the device triggering an interrupt, and you need it in <code>intr_entry</code>. In particular, make sure to read the IRQ number before handling an I/O interrupt from Ethernet and write the number back after handling it. This allows PLIC to fire the next interrupt. Read chapter 10 of <a href="assets/fu540-c000-manual-v1p4.pdf">this CPU manual</a> for more about PLIC.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Enabling and handling I/O interrupts for multiple CPU cores could be tricky. Focus on making your Ethernet driver code work, and you can work on supporting multicore in the next project.</p></div><h3 id="initialize-the-e1000-device" tabindex="-1">Initialize the E1000 device <a class="header-anchor" href="#initialize-the-e1000-device" aria-label="Permalink to &quot;Initialize the E1000 device&quot;">​</a></h3><p>The key concepts in Intel&#39;s E1000 Ethernet controller are the <em>receive descriptor</em> and <em>receive buffer</em>. When E1000 receives an Ethernet frame, it writes the frame into a receive buffer and writes the frame&#39;s metadata (e.g., length) into the corresponding receive descriptor. On the operating system side, egos-2000 reads the descriptors and buffers, and sets the <code>status</code> field of the descriptors as unused for receiving future Ethernet frames.</p><p>Other than the receive descriptors and buffers, you need to initialize a few other things for the E1000 device, such as the MAC address and interrupt mask. Below is a list of the E1000 control registers, which you should learn from <a href="assets/pci-pci-x-family-gbe-controllers-software-dev-manual.pdf">the software developer’s manual from Intel</a>.</p><ul><li><p><strong>0xD0</strong>: Interrupt Mask Set/Read; <strong>0x100</strong>: Receive Control</p></li><li><p><strong>0x2808</strong>: Receive Descriptor Length</p></li><li><p><strong>0x2810</strong>:Receive Descriptor Head; <strong>0x2818</strong>: Receive Descriptor Tail</p></li><li><p><strong>0x2800</strong>: Receive Descriptor Base Low; <strong>0x2804</strong>: Receive Descriptor Base High</p></li><li><p><strong>0x5400</strong>: Receive Address (MAC) Low; <strong>0x5404</strong>: Receive Address (MAC) High</p></li></ul><p>Add your code for initializing the E1000 device in <code>earth/boot.c</code>, and put the common data structures, such as the struct for a receive descriptor, in <code>library/egos.h</code>. Define an array of receive descriptors and an array of receive buffers as global variables in <code>earth/boot.c</code>, and declare them in <code>library/egos.h</code>, so the kernel can access them in <code>intr_entry</code> when printing out the UDP messages within the Ethernet frames received.</p><h3 id="print-out-the-data-received" tabindex="-1">Print out the data received <a class="header-anchor" href="#print-out-the-data-received" aria-label="Permalink to &quot;Print out the data received&quot;">​</a></h3><p>Your last task in this project is print the UDP messages received from Ethernet. Inspect the descriptor right after the Receive Descriptor Tail (i.e., <code>0x2818</code>), and it should indicate that a frame has been received (i.e., bit#0 of the descriptor&#39;s <code>status</code> field is <code>1</code>). Read the data from the corresponding receive buffer, and print out the buffer content at offset 42 (i.e., the size of the headers: <code>42==sizeof(struct ethernet_header eth)+sizeof(struct ip_header ip)+sizeof(struct udp_header udp)</code> according to <code>apps/user/udp_demo.c</code>). Lastly, set the descriptor <code>status</code> field as unused, and advance the Receive Descriptor Tail.</p><p>Again, do not forget to write the IRQ back to PLIC, so PLIC can fire the next I/O interrupt. Do not forget to check your ARP records again, which should map IP address <code>192.168.18.2</code> to MAC address <code>ae:c9:6:72:b2:64</code>. After you finish, you should be able to do the following.</p><div class="language-console vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># In terminal </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># You may need to add sudo before this nc command.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; nc -u 192.168.18.2 8002</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Hello egos-2000!</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">This is Mac/Linux!</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># In terminal </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; make qemu</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[CRITICAL] Welcome to the egos-2000 shell!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">➜ /home/yunhao</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[SUCCESS] Get 59 bytes from rxdesc[0] with UDP message &quot;Hello egos-2000!&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[SUCCESS] Get 61 bytes from rxdesc[1] with UDP message &quot;This is Mac/Linux!&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>The <code>SUCCESS</code> logs above show the Ethernet frame length, the receive descriptor index, and the UDP message at offset 42 of the receive buffer.</p><h2 id="write-a-web-server-with-tcp-ip" tabindex="-1">Write a web server with TCP/IP <a class="header-anchor" href="#write-a-web-server-with-tcp-ip" aria-label="Permalink to &quot;Write a web server with TCP/IP&quot;">​</a></h2><p>After seeing how to send and receive Ethernet frames using UDP, you can start to research how to introduce more of TCP/IP. With TCP, you can write a simple web server listening on TCP port 80 and handling HTTP requests for HTML web pages. One way of doing this is to integrate your Ethernet driver with the <code>uIP</code> library, and this has been explored by Professor Cheng Tan in his <a href="https://naizhengtan.github.io/26spring/" target="_blank" rel="noreferrer">CS6640 at Northeastern University</a>. This <a href="https://github.com/p-shah256/egos-project" target="_blank" rel="noreferrer">student project</a> from CS6640 is an open-sourced reference for this idea.</p><p>Another possibility is to run TCP over Wi-Fi, as demonstrated in <code>apps/user/tcp_demo.c</code> of egos-2000. It requires the Arty A7 board and the <a href="https://digilent.com/reference/pmod/pmodesp32/start" target="_blank" rel="noreferrer">ESP32 Pmod extension</a>. You can read the comments in <code>apps/user/tcp_demo.c</code> for more details. Note that the TCP/IP protocols have been implemented within the ESP32 hardware so that you do not need a software driver for TCP/IP, such as the <code>uIP</code> library. However, this idea does not work on QEMU.</p><h2 id="accomplishments" tabindex="-1">Accomplishments <a class="header-anchor" href="#accomplishments" aria-label="Permalink to &quot;Accomplishments&quot;">​</a></h2><p>You have gained experience with I/O interrupts, platform-level interrupt controller, and the IRQ numbers. You have also gained experience with the Intel Gigabit Ethernet Controller by reading Intel&#39;s manual and implementing the receive functionality. This concludes what we wish to introduce about device drivers in operating systems. We encourage you to research more on implementing a TCP/IP web server on top of this project.</p>`,65),l=[r];function o(p,h,d,c,u,k){return a(),s("div",null,l)}const m=e(t,[["render",o]]);export{b as __pageData,m as default};
